{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"curl | bash","text":""},{"location":"about/","title":"About this site","text":""},{"location":"blog/","title":"News","text":""},{"location":"blog/2026/01/script-openclawai/","title":"Script: openclaw.ai","text":"<p>The OpenClaw installer at <code>openclaw.ai/install.sh</code> is a 1407-line bash script that sets up the OpenClaw CLI tool on macOS and Linux (including WSL). It is invoked via <code>curl -fsSL --proto '=https' --tlsv1.2 https://openclaw.ai/install.sh | bash</code>. The script installs prerequisites (Homebrew on macOS, Node.js 22+, Git), then installs OpenClaw either globally via npm or from a git checkout, configures PATH, and optionally runs onboarding and migration steps.</p>"},{"location":"blog/2026/01/script-openclawai/#script-info","title":"Script info","text":"URL <code>https://openclaw.ai/install.sh</code> Invocation <code>curl -fsSL --proto '=https' --tlsv1.2 https://openclaw.ai/install.sh \\| bash</code> Total lines 1407 Comments 30 lines Blank 138 lines Boilerplate 242 lines (output formatting, colors, usage text) Installation 996 lines (actual work)"},{"location":"blog/2026/01/script-openclawai/#what-does-it-change","title":"What does it change?","text":""},{"location":"blog/2026/01/script-openclawai/#files-and-folders","title":"Files and folders","text":"<ul> <li>Creates <code>~/.npm-global/</code> directory on Linux if npm prefix is not user-writable</li> <li>Creates <code>~/.local/bin/</code> directory and writes an <code>openclaw</code> wrapper script there (git install method)</li> <li>Creates <code>~/.openclaw/</code> config directory (via the <code>openclaw onboard</code> / <code>openclaw doctor</code> subcommands)</li> <li>Clones the OpenClaw repo to <code>~/openclaw</code> (or a specified directory) when using the git install method</li> <li>Writes to <code>~/.bashrc</code> and <code>~/.zshrc</code> to add PATH entries for <code>~/.npm-global/bin</code> and/or <code>~/.local/bin</code></li> </ul>"},{"location":"blog/2026/01/script-openclawai/#packages-installed","title":"Packages installed","text":"<ul> <li>Homebrew (macOS): installs Homebrew itself if missing, by downloading and running <code>https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh</code></li> <li>Node.js 22 (macOS): <code>brew install node@22</code></li> <li>Node.js 22 (Linux): downloads and runs the NodeSource setup script (<code>https://deb.nodesource.com/setup_22.x</code> or <code>https://rpm.nodesource.com/setup_22.x</code>), then installs via <code>apt-get</code>, <code>dnf</code>, or <code>yum</code></li> <li>Git: <code>brew install git</code> (macOS) or <code>apt-get install -y git</code> / <code>dnf install -y git</code> / <code>yum install -y git</code> (Linux)</li> <li>pnpm (git method only): installed via Corepack or <code>npm install -g pnpm@10</code></li> <li>OpenClaw itself: <code>npm install -g openclaw@latest</code> (npm method) or <code>pnpm install</code> + <code>pnpm build</code> in the git checkout (git method)</li> </ul>"},{"location":"blog/2026/01/script-openclawai/#downloads","title":"Downloads","text":"<ul> <li>Homebrew install script from <code>https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh</code> (macOS, if Homebrew is missing)</li> <li>NodeSource setup scripts from <code>https://deb.nodesource.com/setup_22.x</code> or <code>https://rpm.nodesource.com/setup_22.x</code> (Linux, if Node.js is missing)</li> <li>OpenClaw git repo from <code>https://github.com/openclaw/openclaw.git</code> (git install method)</li> <li>OpenClaw npm package from the npm registry (npm install method)</li> </ul>"},{"location":"blog/2026/01/script-openclawai/#environment-changes","title":"Environment changes","text":"<ul> <li>Adds <code>~/.npm-global/bin</code> to PATH in <code>~/.bashrc</code> and <code>~/.zshrc</code> (Linux, when fixing npm permissions)</li> <li>Adds <code>~/.local/bin</code> to PATH in <code>~/.bashrc</code> and <code>~/.zshrc</code> (git install method)</li> <li>Exports modified PATH within the current session for Homebrew shellenv, npm global bin, and user-local bin</li> <li>Sets <code>npm config set prefix \"$HOME/.npm-global\"</code> on Linux when the default prefix is not user-writable</li> <li>Runs <code>openclaw onboard</code> and <code>openclaw doctor</code> which may create or modify OpenClaw configuration files</li> </ul>"},{"location":"blog/2026/01/script-openclawai/#permissions","title":"Permissions","text":"<ul> <li>Uses <code>sudo</code> on Linux for system-level package installs (NodeSource setup, apt-get/dnf/yum)</li> <li>Runs <code>chmod +x</code> on the <code>~/.local/bin/openclaw</code> wrapper script (git install method)</li> <li>Creates symlinks in the npm global bin directory to the OpenClaw entry point</li> </ul>"},{"location":"blog/2026/01/script-openclawai/#full-source","title":"Full source","text":"<p>The full script source is saved as <code>scripts/openclaw_ai_install_sh.txt</code>.</p>"},{"location":"examples/frankenphp.dev.5a/","title":"frankenphp.dev/install.sh","text":""},{"location":"examples/frankenphp.dev.5a/#description","title":"Description","text":"<ul> <li>run <code>curl -s https://frankenphp.dev/install.sh | bash</code> to install FrankenPHP</li> <li>cf https://frankenphp.dev/docs/ </li> </ul>"},{"location":"examples/frankenphp.dev.5a/#stats","title":"Stats","text":"<pre><code>-------------------------------------------------------------------------------\nLanguage                     files          blank        comment           code\n-------------------------------------------------------------------------------\nBourne Shell                     1             14              2             72\n-------------------------------------------------------------------------------\n</code></pre>"},{"location":"examples/frankenphp.dev.5a/#code","title":"Code","text":"<pre><code>#!/bin/sh\n\nset -e\n\nif [ -z \"${BIN_DIR}\" ]; then\n    BIN_DIR=$(pwd)\nfi\n\nTHE_ARCH_BIN=\"\"\nDEST=${BIN_DIR}/frankenphp\n\nOS=$(uname -s)\nARCH=$(uname -m)\n\nif type \"tput\" &gt;/dev/null 2&gt;&amp;1; then\n    bold=$(tput bold || true)\n    italic=$(tput sitm || true)\n    normal=$(tput sgr0 || true)\nfi\n\ncase ${OS} in\nLinux*)\n    case ${ARCH} in\n    aarch64)\n        THE_ARCH_BIN=\"frankenphp-linux-aarch64\"\n        ;;\n    x86_64)\n        THE_ARCH_BIN=\"frankenphp-linux-x86_64\"\n        ;;\n    *)\n        THE_ARCH_BIN=\"\"\n        ;;\n    esac\n    ;;\nDarwin*)\n    case ${ARCH} in\n    arm64)\n        THE_ARCH_BIN=\"frankenphp-mac-arm64\"\n        ;;\n    *)\n        THE_ARCH_BIN=\"frankenphp-mac-x86_64\"\n        ;;\n    esac\n    ;;\nWindows | MINGW64_NT*)\n    echo \"\u2757 Use WSL to run FrankenPHP on Windows: https://learn.microsoft.com/windows/wsl/\"\n    exit 1\n    ;;\n*)\n    THE_ARCH_BIN=\"\"\n    ;;\nesac\n\nif [ -z \"${THE_ARCH_BIN}\" ]; then\n    echo \"\u2757 FrankenPHP is not supported on ${OS} and ${ARCH}\"\n    exit 1\nfi\n\nSUDO=\"\"\n\necho \"\ud83d\udce6 Downloading ${bold}FrankenPHP${normal} for ${OS} (${ARCH}):\"\n\n# check if $DEST is writable and suppress an error message\ntouch \"${DEST}\" 2&gt;/dev/null\n\n# we need sudo powers to write to DEST\nif [ $? -eq 1 ]; then\n    echo \"\u2757 You do not have permission to write to ${italic}${DEST}${normal}, enter your password to \ngrant sudo powers\"\n    SUDO=\"sudo\"\nfi\n\nif type \"curl\" &gt;/dev/null 2&gt;&amp;1; then\n    curl -L --progress-bar \n\"https://github.com/dunglas/frankenphp/releases/latest/download/${THE_ARCH_BIN}\" -o \"${DEST}\"\nelif type \"wget\" &gt;/dev/null 2&gt;&amp;1; then\n    ${SUDO} wget \"https://github.com/dunglas/frankenphp/releases/latest/download/${THE_ARCH_BIN}\" -O \n\"${DEST}\"\nelse\n    echo \"\u2757 Please install ${italic}curl${normal} or ${italic}wget${normal} to download FrankenPHP\"\n    exit 1\nfi\n\n${SUDO} chmod +x \"${DEST}\"\n\necho\necho \"\ud83e\udd73 FrankenPHP downloaded successfully to ${italic}${DEST}${normal}\"\necho \"\ud83d\udd27 Move the binary to ${italic}/usr/local/bin/${normal} or another directory in your \n${italic}PATH${normal} to use it globally:\"\necho \"   ${bold}sudo mv ${DEST} /usr/local/bin/${normal}\"\necho\necho \"\u2b50 If you like FrankenPHP, please give it a star on GitHub: \n${italic}https://github.com/dunglas/frankenphp${normal}\"\n</code></pre>"},{"location":"examples/get.docker.com.ff/","title":"get.docker.com","text":""},{"location":"examples/get.docker.com.ff/#description","title":"Description","text":"<ul> <li>run <code>curl -s https://get.docker.com | bash</code> to install Docker</li> <li>cf https://docs.docker.com/engine/install/ubuntu/ </li> </ul>"},{"location":"examples/get.docker.com.ff/#stats","title":"Stats","text":"<pre><code>-------------------------------------------------------------------------------\nLanguage                     files          blank        comment           code\n-------------------------------------------------------------------------------\nBourne Shell                     1             53            134            566\n-------------------------------------------------------------------------------\n</code></pre>"},{"location":"examples/get.docker.com.ff/#code","title":"Code","text":"<pre><code>#!/bin/sh\nset -e\n# Docker Engine for Linux installation script.\n#\n# This script is intended as a convenient way to configure docker's package\n# repositories and to install Docker Engine, This script is not recommended\n# for production environments. Before running this script, make yourself familiar\n# with potential risks and limitations, and refer to the installation manual\n# at https://docs.docker.com/engine/install/ for alternative installation methods.\n#\n# The script:\n#\n# - Requires `root` or `sudo` privileges to run.\n# - Attempts to detect your Linux distribution and version and configure your\n#   package management system for you.\n# - Doesn't allow you to customize most installation parameters.\n# - Installs dependencies and recommendations without asking for confirmation.\n# - Installs the latest stable release (by default) of Docker CLI, Docker Engine,\n#   Docker Buildx, Docker Compose, containerd, and runc. When using this script\n#   to provision a machine, this may result in unexpected major version upgrades\n#   of these packages. Always test upgrades in a test environment before\n#   deploying to your production systems.\n# - Isn't designed to upgrade an existing Docker installation. When using the\n#   script to update an existing installation, dependencies may not be updated\n#   to the expected version, resulting in outdated versions.\n#\n# Source code is available at https://github.com/docker/docker-install/\n#\n# Usage\n# ==============================================================================\n#\n# To install the latest stable versions of Docker CLI, Docker Engine, and their\n# dependencies:\n#\n# 1. download the script\n#\n#   $ curl -fsSL https://get.docker.com -o install-docker.sh\n#\n# 2. verify the script's content\n#\n#   $ cat install-docker.sh\n#\n# 3. run the script with --dry-run to verify the steps it executes\n#\n#   $ sh install-docker.sh --dry-run\n#\n# 4. run the script either as root, or using sudo to perform the installation.\n#\n#   $ sudo sh install-docker.sh\n#\n# Command-line options\n# ==============================================================================\n#\n# --version &lt;VERSION&gt;\n# Use the --version option to install a specific version, for example:\n#\n#   $ sudo sh install-docker.sh --version 23.0\n#\n# --channel &lt;stable|test&gt;\n#\n# Use the --channel option to install from an alternative installation channel.\n# The following example installs the latest versions from the \"test\" channel,\n# which includes pre-releases (alpha, beta, rc):\n#\n#   $ sudo sh install-docker.sh --channel test\n#\n# Alternatively, use the script at https://test.docker.com, which uses the test\n# channel as default.\n#\n# --mirror &lt;Aliyun|AzureChinaCloud&gt;\n#\n# Use the --mirror option to install from a mirror supported by this script.\n# Available mirrors are \"Aliyun\" (https://mirrors.aliyun.com/docker-ce), and\n# \"AzureChinaCloud\" (https://mirror.azure.cn/docker-ce), for example:\n#\n#   $ sudo sh install-docker.sh --mirror AzureChinaCloud\n#\n# ==============================================================================\n\n\n# Git commit from https://github.com/docker/docker-install when\n# the script was uploaded (Should only be modified by upload job):\nSCRIPT_COMMIT_SHA=\"4c94a56999e10efcf48c5b8e3f6afea464f9108e\"\n\n# strip \"v\" prefix if present\nVERSION=\"${VERSION#v}\"\n\n# The channel to install from:\n#   * stable\n#   * test\nDEFAULT_CHANNEL_VALUE=\"stable\"\nif [ -z \"$CHANNEL\" ]; then\n    CHANNEL=$DEFAULT_CHANNEL_VALUE\nfi\n\nDEFAULT_DOWNLOAD_URL=\"https://download.docker.com\"\nif [ -z \"$DOWNLOAD_URL\" ]; then\n    DOWNLOAD_URL=$DEFAULT_DOWNLOAD_URL\nfi\n\nDEFAULT_REPO_FILE=\"docker-ce.repo\"\nif [ -z \"$REPO_FILE\" ]; then\n    REPO_FILE=\"$DEFAULT_REPO_FILE\"\nfi\n\nmirror=''\nDRY_RUN=${DRY_RUN:-}\nwhile [ $# -gt 0 ]; do\n    case \"$1\" in\n        --channel)\n            CHANNEL=\"$2\"\n            shift\n            ;;\n        --dry-run)\n            DRY_RUN=1\n            ;;\n        --mirror)\n            mirror=\"$2\"\n            shift\n            ;;\n        --version)\n            VERSION=\"${2#v}\"\n            shift\n            ;;\n        --*)\n            echo \"Illegal option $1\"\n            ;;\n    esac\n    shift $(( $# &gt; 0 ? 1 : 0 ))\ndone\n\ncase \"$mirror\" in\n    Aliyun)\n        DOWNLOAD_URL=\"https://mirrors.aliyun.com/docker-ce\"\n        ;;\n    AzureChinaCloud)\n        DOWNLOAD_URL=\"https://mirror.azure.cn/docker-ce\"\n        ;;\n    \"\")\n        ;;\n    *)\n        &gt;&amp;2 echo \"unknown mirror '$mirror': use either 'Aliyun', or 'AzureChinaCloud'.\"\n        exit 1\n        ;;\nesac\n\ncase \"$CHANNEL\" in\n    stable|test)\n        ;;\n    *)\n        &gt;&amp;2 echo \"unknown CHANNEL '$CHANNEL': use either stable or test.\"\n        exit 1\n        ;;\nesac\n\ncommand_exists() {\n    command -v \"$@\" &gt; /dev/null 2&gt;&amp;1\n}\n\n# version_gte checks if the version specified in $VERSION is at least the given\n# SemVer (Maj.Minor[.Patch]), or CalVer (YY.MM) version.It returns 0 (success)\n# if $VERSION is either unset (=latest) or newer or equal than the specified\n# version, or returns 1 (fail) otherwise.\n#\n# examples:\n#\n# VERSION=23.0\n# version_gte 23.0  // 0 (success)\n# version_gte 20.10 // 0 (success)\n# version_gte 19.03 // 0 (success)\n# version_gte 26.1  // 1 (fail)\nversion_gte() {\n    if [ -z \"$VERSION\" ]; then\n            return 0\n    fi\n    version_compare \"$VERSION\" \"$1\"\n}\n\n# version_compare compares two version strings (either SemVer (Major.Minor.Path),\n# or CalVer (YY.MM) version strings. It returns 0 (success) if version A is newer\n# or equal than version B, or 1 (fail) otherwise. Patch releases and pre-release\n# (-alpha/-beta) are not taken into account\n#\n# examples:\n#\n# version_compare 23.0.0 20.10 // 0 (success)\n# version_compare 23.0 20.10   // 0 (success)\n# version_compare 20.10 19.03  // 0 (success)\n# version_compare 20.10 20.10  // 0 (success)\n# version_compare 19.03 20.10  // 1 (fail)\nversion_compare() (\n    set +x\n\n    yy_a=\"$(echo \"$1\" | cut -d'.' -f1)\"\n    yy_b=\"$(echo \"$2\" | cut -d'.' -f1)\"\n    if [ \"$yy_a\" -lt \"$yy_b\" ]; then\n        return 1\n    fi\n    if [ \"$yy_a\" -gt \"$yy_b\" ]; then\n        return 0\n    fi\n    mm_a=\"$(echo \"$1\" | cut -d'.' -f2)\"\n    mm_b=\"$(echo \"$2\" | cut -d'.' -f2)\"\n\n    # trim leading zeros to accommodate CalVer\n    mm_a=\"${mm_a#0}\"\n    mm_b=\"${mm_b#0}\"\n\n    if [ \"${mm_a:-0}\" -lt \"${mm_b:-0}\" ]; then\n        return 1\n    fi\n\n    return 0\n)\n\nis_dry_run() {\n    if [ -z \"$DRY_RUN\" ]; then\n        return 1\n    else\n        return 0\n    fi\n}\n\nis_wsl() {\n    case \"$(uname -r)\" in\n    *microsoft* ) true ;; # WSL 2\n    *Microsoft* ) true ;; # WSL 1\n    * ) false;;\n    esac\n}\n\nis_darwin() {\n    case \"$(uname -s)\" in\n    *darwin* ) true ;;\n    *Darwin* ) true ;;\n    * ) false;;\n    esac\n}\n\ndeprecation_notice() {\n    distro=$1\n    distro_version=$2\n    echo\n    printf \"\\033[91;1mDEPRECATION WARNING\\033[0m\\n\"\n    printf \"    This Linux distribution (\\033[1m%s %s\\033[0m) reached end-of-life and is no longer \nsupported by this script.\\n\" \"$distro\" \"$distro_version\"\n    echo   \"    No updates or security fixes will be released for this distribution, and users are \nrecommended\"\n    echo   \"    to upgrade to a currently maintained version of $distro.\"\n    echo\n    printf   \"Press \\033[1mCtrl+C\\033[0m now to abort this script, or wait for the installation to \ncontinue.\"\n    echo\n    sleep 10\n}\n\nget_distribution() {\n    lsb_dist=\"\"\n    # Every system that we officially support has /etc/os-release\n    if [ -r /etc/os-release ]; then\n        lsb_dist=\"$(. /etc/os-release &amp;&amp; echo \"$ID\")\"\n    fi\n    # Returning an empty string here should be alright since the\n    # case statements don't act unless you provide an actual value\n    echo \"$lsb_dist\"\n}\n\necho_docker_as_nonroot() {\n    if is_dry_run; then\n        return\n    fi\n    if command_exists docker &amp;&amp; [ -e /var/run/docker.sock ]; then\n        (\n            set -x\n            $sh_c 'docker version'\n        ) || true\n    fi\n\n    # intentionally mixed spaces and tabs here -- tabs are stripped by \"&lt;&lt;-EOF\", spaces are kept in the \noutput\n    echo\n    echo \"================================================================================\"\n    echo\n    if version_gte \"20.10\"; then\n        echo \"To run Docker as a non-privileged user, consider setting up the\"\n        echo \"Docker daemon in rootless mode for your user:\"\n        echo\n        echo \"    dockerd-rootless-setuptool.sh install\"\n        echo\n        echo \"Visit https://docs.docker.com/go/rootless/ to learn about rootless mode.\"\n        echo\n    fi\n    echo\n    echo \"To run the Docker daemon as a fully privileged service, but granting non-root\"\n    echo \"users access, refer to https://docs.docker.com/go/daemon-access/\"\n    echo\n    echo \"WARNING: Access to the remote API on a privileged Docker daemon is equivalent\"\n    echo \"         to root access on the host. Refer to the 'Docker daemon attack surface'\"\n    echo \"         documentation for details: https://docs.docker.com/go/attack-surface/\"\n    echo\n    echo \"================================================================================\"\n    echo\n}\n\n# Check if this is a forked Linux distro\ncheck_forked() {\n\n    # Check for lsb_release command existence, it usually exists in forked distros\n    if command_exists lsb_release; then\n        # Check if the `-u` option is supported\n        set +e\n        lsb_release -a -u &gt; /dev/null 2&gt;&amp;1\n        lsb_release_exit_code=$?\n        set -e\n\n        # Check if the command has exited successfully, it means we're in a forked distro\n        if [ \"$lsb_release_exit_code\" = \"0\" ]; then\n            # Print info about current distro\n            cat &lt;&lt;-EOF\n            You're using '$lsb_dist' version '$dist_version'.\n            EOF\n\n            # Get the upstream release info\n            lsb_dist=$(lsb_release -a -u 2&gt;&amp;1 | tr '[:upper:]' '[:lower:]' | grep -E 'id' | cut \n-d ':' -f 2 | tr -d '[:space:]')\n            dist_version=$(lsb_release -a -u 2&gt;&amp;1 | tr '[:upper:]' '[:lower:]' | grep -E \n'codename' | cut -d ':' -f 2 | tr -d '[:space:]')\n\n            # Print info about upstream distro\n            cat &lt;&lt;-EOF\n            Upstream release is '$lsb_dist' version '$dist_version'.\n            EOF\n        else\n            if [ -r /etc/debian_version ] &amp;&amp; [ \"$lsb_dist\" != \"ubuntu\" ] &amp;&amp; [ \"$lsb_dist\" != \n\"raspbian\" ]; then\n                if [ \"$lsb_dist\" = \"osmc\" ]; then\n                    # OSMC runs Raspbian\n                    lsb_dist=raspbian\n                else\n                    # We're Debian and don't even know it!\n                    lsb_dist=debian\n                fi\n                dist_version=\"$(sed 's/\\/.*//' /etc/debian_version | sed 's/\\..*//')\"\n                case \"$dist_version\" in\n                    12)\n                        dist_version=\"bookworm\"\n                    ;;\n                    11)\n                        dist_version=\"bullseye\"\n                    ;;\n                    10)\n                        dist_version=\"buster\"\n                    ;;\n                    9)\n                        dist_version=\"stretch\"\n                    ;;\n                    8)\n                        dist_version=\"jessie\"\n                    ;;\n                esac\n            fi\n        fi\n    fi\n}\n\ndo_install() {\n    echo \"# Executing docker install script, commit: $SCRIPT_COMMIT_SHA\"\n\n    if command_exists docker; then\n        cat &gt;&amp;2 &lt;&lt;-'EOF'\n            Warning: the \"docker\" command appears to already exist on this system.\n\n            If you already have Docker installed, this script can cause trouble, which is\n            why we're displaying this warning and provide the opportunity to cancel the\n            installation.\n\n            If you installed the current Docker package using this script and are using it\n            again to update Docker, you can ignore this message, but be aware that the\n            script resets any custom changes in the deb and rpm repo configuration\n            files to match the parameters passed to the script.\n\n            You may press Ctrl+C now to abort this script.\n        EOF\n        ( set -x; sleep 20 )\n    fi\n\n    user=\"$(id -un 2&gt;/dev/null || true)\"\n\n    sh_c='sh -c'\n    if [ \"$user\" != 'root' ]; then\n        if command_exists sudo; then\n            sh_c='sudo -E sh -c'\n        elif command_exists su; then\n            sh_c='su -c'\n        else\n            cat &gt;&amp;2 &lt;&lt;-'EOF'\n            Error: this installer needs the ability to run commands as root.\n            We are unable to find either \"sudo\" or \"su\" available to make this happen.\n            EOF\n            exit 1\n        fi\n    fi\n\n    if is_dry_run; then\n        sh_c=\"echo\"\n    fi\n\n    # perform some very rudimentary platform detection\n    lsb_dist=$( get_distribution )\n    lsb_dist=\"$(echo \"$lsb_dist\" | tr '[:upper:]' '[:lower:]')\"\n\n    if is_wsl; then\n        echo\n        echo \"WSL DETECTED: We recommend using Docker Desktop for Windows.\"\n        echo \"Please get Docker Desktop from https://www.docker.com/products/docker-desktop/\"\n        echo\n        cat &gt;&amp;2 &lt;&lt;-'EOF'\n\n            You may press Ctrl+C now to abort this script.\n        EOF\n        ( set -x; sleep 20 )\n    fi\n\n    case \"$lsb_dist\" in\n\n        ubuntu)\n            if command_exists lsb_release; then\n                dist_version=\"$(lsb_release --codename | cut -f2)\"\n            fi\n            if [ -z \"$dist_version\" ] &amp;&amp; [ -r /etc/lsb-release ]; then\n                dist_version=\"$(. /etc/lsb-release &amp;&amp; echo \"$DISTRIB_CODENAME\")\"\n            fi\n        ;;\n\n        debian|raspbian)\n            dist_version=\"$(sed 's/\\/.*//' /etc/debian_version | sed 's/\\..*//')\"\n            case \"$dist_version\" in\n                12)\n                    dist_version=\"bookworm\"\n                ;;\n                11)\n                    dist_version=\"bullseye\"\n                ;;\n                10)\n                    dist_version=\"buster\"\n                ;;\n                9)\n                    dist_version=\"stretch\"\n                ;;\n                8)\n                    dist_version=\"jessie\"\n                ;;\n            esac\n        ;;\n\n        centos|rhel)\n            if [ -z \"$dist_version\" ] &amp;&amp; [ -r /etc/os-release ]; then\n                dist_version=\"$(. /etc/os-release &amp;&amp; echo \"$VERSION_ID\")\"\n            fi\n        ;;\n\n        *)\n            if command_exists lsb_release; then\n                dist_version=\"$(lsb_release --release | cut -f2)\"\n            fi\n            if [ -z \"$dist_version\" ] &amp;&amp; [ -r /etc/os-release ]; then\n                dist_version=\"$(. /etc/os-release &amp;&amp; echo \"$VERSION_ID\")\"\n            fi\n        ;;\n\n    esac\n\n    # Check if this is a forked Linux distro\n    check_forked\n\n    # Print deprecation warnings for distro versions that recently reached EOL,\n    # but may still be commonly used (especially LTS versions).\n    case \"$lsb_dist.$dist_version\" in\n        centos.8|centos.7|rhel.7)\n            deprecation_notice \"$lsb_dist\" \"$dist_version\"\n            ;;\n        debian.buster|debian.stretch|debian.jessie)\n            deprecation_notice \"$lsb_dist\" \"$dist_version\"\n            ;;\n        raspbian.buster|raspbian.stretch|raspbian.jessie)\n            deprecation_notice \"$lsb_dist\" \"$dist_version\"\n            ;;\n        ubuntu.bionic|ubuntu.xenial|ubuntu.trusty)\n            deprecation_notice \"$lsb_dist\" \"$dist_version\"\n            ;;\n\nubuntu.mantic|ubuntu.lunar|ubuntu.kinetic|ubuntu.impish|ubuntu.hirsute|ubuntu.groovy|ubuntu.eoan|ubuntu.disco|\nubuntu.cosmic)\n            deprecation_notice \"$lsb_dist\" \"$dist_version\"\n            ;;\n        fedora.*)\n            if [ \"$dist_version\" -lt 40 ]; then\n                deprecation_notice \"$lsb_dist\" \"$dist_version\"\n            fi\n            ;;\n    esac\n\n    # Run setup for each distro accordingly\n    case \"$lsb_dist\" in\n        ubuntu|debian|raspbian)\n            pre_reqs=\"ca-certificates curl\"\n            apt_repo=\"deb [arch=$(dpkg --print-architecture) \nsigned-by=/etc/apt/keyrings/docker.asc] $DOWNLOAD_URL/linux/$lsb_dist $dist_version $CHANNEL\"\n            (\n                if ! is_dry_run; then\n                    set -x\n                fi\n                $sh_c 'apt-get -qq update &gt;/dev/null'\n                $sh_c \"DEBIAN_FRONTEND=noninteractive apt-get -y -qq install $pre_reqs \n&gt;/dev/null\"\n                $sh_c 'install -m 0755 -d /etc/apt/keyrings'\n                $sh_c \"curl -fsSL \\\"$DOWNLOAD_URL/linux/$lsb_dist/gpg\\\" -o \n/etc/apt/keyrings/docker.asc\"\n                $sh_c \"chmod a+r /etc/apt/keyrings/docker.asc\"\n                $sh_c \"echo \\\"$apt_repo\\\" &gt; /etc/apt/sources.list.d/docker.list\"\n                $sh_c 'apt-get -qq update &gt;/dev/null'\n            )\n            pkg_version=\"\"\n            if [ -n \"$VERSION\" ]; then\n                if is_dry_run; then\n                    echo \"# WARNING: VERSION pinning is not supported in DRY_RUN\"\n                else\n                    # Will work for incomplete versions IE (17.12), but may not actually \ngrab the \"latest\" if in the test channel\n                    pkg_pattern=\"$(echo \"$VERSION\" | sed 's/-ce-/~ce~.*/g' | sed \n's/-/.*/g')\"\n                    search_command=\"apt-cache madison docker-ce | grep '$pkg_pattern' | \nhead -1 | awk '{\\$1=\\$1};1' | cut -d' ' -f 3\"\n                    pkg_version=\"$($sh_c \"$search_command\")\"\n                    echo \"INFO: Searching repository for VERSION '$VERSION'\"\n                    echo \"INFO: $search_command\"\n                    if [ -z \"$pkg_version\" ]; then\n                        echo\n                        echo \"ERROR: '$VERSION' not found amongst apt-cache madison \nresults\"\n                        echo\n                        exit 1\n                    fi\n                    if version_gte \"18.09\"; then\n                            search_command=\"apt-cache madison docker-ce-cli | \ngrep '$pkg_pattern' | head -1 | awk '{\\$1=\\$1};1' | cut -d' ' -f 3\"\n                            echo \"INFO: $search_command\"\n                            cli_pkg_version=\"=$($sh_c \"$search_command\")\"\n                    fi\n                    pkg_version=\"=$pkg_version\"\n                fi\n            fi\n            (\n                pkgs=\"docker-ce${pkg_version%=}\"\n                if version_gte \"18.09\"; then\n                        # older versions didn't ship the cli and containerd as \nseparate packages\n                        pkgs=\"$pkgs docker-ce-cli${cli_pkg_version%=} containerd.io\"\n                fi\n                if version_gte \"20.10\"; then\n                        pkgs=\"$pkgs docker-compose-plugin \ndocker-ce-rootless-extras$pkg_version\"\n                fi\n                if version_gte \"23.0\"; then\n                        pkgs=\"$pkgs docker-buildx-plugin\"\n                fi\n                if ! is_dry_run; then\n                    set -x\n                fi\n                $sh_c \"DEBIAN_FRONTEND=noninteractive apt-get -y -qq install $pkgs &gt;/dev/null\"\n            )\n            echo_docker_as_nonroot\n            exit 0\n            ;;\n        centos|fedora|rhel)\n            repo_file_url=\"$DOWNLOAD_URL/linux/$lsb_dist/$REPO_FILE\"\n            (\n                if ! is_dry_run; then\n                    set -x\n                fi\n                if command_exists dnf5; then\n                    $sh_c \"dnf -y -q --setopt=install_weak_deps=False install \ndnf-plugins-core\"\n                    $sh_c \"dnf5 config-manager addrepo --overwrite \n--save-filename=docker-ce.repo --from-repofile='$repo_file_url'\"\n\n                    if [ \"$CHANNEL\" != \"stable\" ]; then\n                        $sh_c \"dnf5 config-manager setopt \\\"docker-ce-*.enabled=0\\\"\"\n                        $sh_c \"dnf5 config-manager setopt \n\\\"docker-ce-$CHANNEL.enabled=1\\\"\"\n                    fi\n                    $sh_c \"dnf makecache\"\n                elif command_exists dnf; then\n                    $sh_c \"dnf -y -q --setopt=install_weak_deps=False install \ndnf-plugins-core\"\n                    $sh_c \"rm -f /etc/yum.repos.d/docker-ce.repo  \n/etc/yum.repos.d/docker-ce-staging.repo\"\n                    $sh_c \"dnf config-manager --add-repo $repo_file_url\"\n\n                    if [ \"$CHANNEL\" != \"stable\" ]; then\n                        $sh_c \"dnf config-manager --set-disabled \\\"docker-ce-*\\\"\"\n                        $sh_c \"dnf config-manager --set-enabled \n\\\"docker-ce-$CHANNEL\\\"\"\n                    fi\n                    $sh_c \"dnf makecache\"\n                else\n                    $sh_c \"yum -y -q install yum-utils\"\n                    $sh_c \"rm -f /etc/yum.repos.d/docker-ce.repo  \n/etc/yum.repos.d/docker-ce-staging.repo\"\n                    $sh_c \"yum-config-manager --add-repo $repo_file_url\"\n\n                    if [ \"$CHANNEL\" != \"stable\" ]; then\n                        $sh_c \"yum-config-manager --disable \\\"docker-ce-*\\\"\"\n                        $sh_c \"yum-config-manager --enable \\\"docker-ce-$CHANNEL\\\"\"\n                    fi\n                    $sh_c \"yum makecache\"\n                fi\n            )\n            pkg_version=\"\"\n            if command_exists dnf; then\n                pkg_manager=\"dnf\"\n                pkg_manager_flags=\"-y -q --best\"\n            else\n                pkg_manager=\"yum\"\n                pkg_manager_flags=\"-y -q\"\n            fi\n            if [ -n \"$VERSION\" ]; then\n                if is_dry_run; then\n                    echo \"# WARNING: VERSION pinning is not supported in DRY_RUN\"\n                else\n                    if [ \"$lsb_dist\" = \"fedora\" ]; then\n                        pkg_suffix=\"fc$dist_version\"\n                    else\n                        pkg_suffix=\"el\"\n                    fi\n                    pkg_pattern=\"$(echo \"$VERSION\" | sed 's/-ce-/\\\\\\\\.ce.*/g' | sed \n's/-/.*/g').*$pkg_suffix\"\n                    search_command=\"$pkg_manager list --showduplicates docker-ce | grep \n'$pkg_pattern' | tail -1 | awk '{print \\$2}'\"\n                    pkg_version=\"$($sh_c \"$search_command\")\"\n                    echo \"INFO: Searching repository for VERSION '$VERSION'\"\n                    echo \"INFO: $search_command\"\n                    if [ -z \"$pkg_version\" ]; then\n                        echo\n                        echo \"ERROR: '$VERSION' not found amongst $pkg_manager list \nresults\"\n                        echo\n                        exit 1\n                    fi\n                    if version_gte \"18.09\"; then\n                        # older versions don't support a cli package\n                        search_command=\"$pkg_manager list --showduplicates \ndocker-ce-cli | grep '$pkg_pattern' | tail -1 | awk '{print \\$2}'\"\n                        cli_pkg_version=\"$($sh_c \"$search_command\" | cut -d':' -f 2)\"\n                    fi\n                    # Cut out the epoch and prefix with a '-'\n                    pkg_version=\"-$(echo \"$pkg_version\" | cut -d':' -f 2)\"\n                fi\n            fi\n            (\n                pkgs=\"docker-ce$pkg_version\"\n                if version_gte \"18.09\"; then\n                    # older versions didn't ship the cli and containerd as separate \npackages\n                    if [ -n \"$cli_pkg_version\" ]; then\n                        pkgs=\"$pkgs docker-ce-cli-$cli_pkg_version containerd.io\"\n                    else\n                        pkgs=\"$pkgs docker-ce-cli containerd.io\"\n                    fi\n                fi\n                if version_gte \"20.10\"; then\n                    pkgs=\"$pkgs docker-compose-plugin \ndocker-ce-rootless-extras$pkg_version\"\n                fi\n                if version_gte \"23.0\"; then\n                        pkgs=\"$pkgs docker-buildx-plugin\"\n                fi\n                if ! is_dry_run; then\n                    set -x\n                fi\n                $sh_c \"$pkg_manager $pkg_manager_flags install $pkgs\"\n            )\n            echo_docker_as_nonroot\n            exit 0\n            ;;\n        sles)\n            if [ \"$(uname -m)\" != \"s390x\" ]; then\n                echo \"Packages for SLES are currently only available for s390x\"\n                exit 1\n            fi\n            repo_file_url=\"$DOWNLOAD_URL/linux/$lsb_dist/$REPO_FILE\"\n            pre_reqs=\"ca-certificates curl libseccomp2 awk\"\n            (\n                if ! is_dry_run; then\n                    set -x\n                fi\n                $sh_c \"zypper install -y $pre_reqs\"\n                $sh_c \"rm -f /etc/zypp/repos.d/docker-ce-*.repo\"\n                $sh_c \"zypper addrepo $repo_file_url\"\n\n\nopensuse_factory_url=\"https://download.opensuse.org/repositories/security:/SELinux/openSUSE_Factory/\"\n                if ! zypper lr -d | grep -q \"${opensuse_factory_url}\"; then\n                    opensuse_repo=\"${opensuse_factory_url}security:SELinux.repo\"\n                    if ! is_dry_run; then\n                        cat &gt;&amp;2 &lt;&lt;- EOF\n                            WARNING!!\n                            openSUSE repository ($opensuse_repo) will be enabled \nnow.\n                            Do you wish to continue?\n                            You may press Ctrl+C now to abort this script.\n                        EOF\n                        ( set -x; sleep 20 )\n                    fi\n                    $sh_c \"zypper addrepo $opensuse_repo\"\n                fi\n                $sh_c \"zypper --gpg-auto-import-keys refresh\"\n                $sh_c \"zypper lr -d\"\n            )\n            pkg_version=\"\"\n            if [ -n \"$VERSION\" ]; then\n                if is_dry_run; then\n                    echo \"# WARNING: VERSION pinning is not supported in DRY_RUN\"\n                else\n                    pkg_pattern=\"$(echo \"$VERSION\" | sed 's/-ce-/\\\\\\\\.ce.*/g' | sed \n's/-/.*/g')\"\n                    search_command=\"zypper search -s --match-exact 'docker-ce' | grep \n'$pkg_pattern' | tail -1 | awk '{print \\$6}'\"\n                    pkg_version=\"$($sh_c \"$search_command\")\"\n                    echo \"INFO: Searching repository for VERSION '$VERSION'\"\n                    echo \"INFO: $search_command\"\n                    if [ -z \"$pkg_version\" ]; then\n                        echo\n                        echo \"ERROR: '$VERSION' not found amongst zypper list results\"\n                        echo\n                        exit 1\n                    fi\n                    search_command=\"zypper search -s --match-exact 'docker-ce-cli' | grep \n'$pkg_pattern' | tail -1 | awk '{print \\$6}'\"\n                    # It's okay for cli_pkg_version to be blank, since older versions \ndon't support a cli package\n                    cli_pkg_version=\"$($sh_c \"$search_command\")\"\n                    pkg_version=\"-$pkg_version\"\n                fi\n            fi\n            (\n                pkgs=\"docker-ce$pkg_version\"\n                if version_gte \"18.09\"; then\n                    if [ -n \"$cli_pkg_version\" ]; then\n                        # older versions didn't ship the cli and containerd as \nseparate packages\n                        pkgs=\"$pkgs docker-ce-cli-$cli_pkg_version containerd.io\"\n                    else\n                        pkgs=\"$pkgs docker-ce-cli containerd.io\"\n                    fi\n                fi\n                if version_gte \"20.10\"; then\n                    pkgs=\"$pkgs docker-compose-plugin \ndocker-ce-rootless-extras$pkg_version\"\n                fi\n                if version_gte \"23.0\"; then\n                        pkgs=\"$pkgs docker-buildx-plugin\"\n                fi\n                if ! is_dry_run; then\n                    set -x\n                fi\n                $sh_c \"zypper -q install -y $pkgs\"\n            )\n            echo_docker_as_nonroot\n            exit 0\n            ;;\n        *)\n            if [ -z \"$lsb_dist\" ]; then\n                if is_darwin; then\n                    echo\n                    echo \"ERROR: Unsupported operating system 'macOS'\"\n                    echo \"Please get Docker Desktop from \nhttps://www.docker.com/products/docker-desktop\"\n                    echo\n                    exit 1\n                fi\n            fi\n            echo\n            echo \"ERROR: Unsupported distribution '$lsb_dist'\"\n            echo\n            exit 1\n            ;;\n    esac\n    exit 1\n}\n\n# wrapped up in a function so that we have some protection against only getting\n# half the file during \"curl | sh\"\ndo_install\n</code></pre>"},{"location":"examples/install.sandstorm.io.69/","title":"install.sandstorm.io","text":""},{"location":"examples/install.sandstorm.io.69/#description","title":"Description","text":"<ul> <li>run <code>curl -s https://install.sandstorm.io | bash</code> to install Sandstorm self-hosting platform</li> <li>cf https://sandstorm.org/install </li> </ul>"},{"location":"examples/install.sandstorm.io.69/#stats","title":"Stats","text":"<pre><code>-------------------------------------------------------------------------------\nLanguage                     files          blank        comment           code\n-------------------------------------------------------------------------------\nBourne Shell                     1            285            464           1403\n-------------------------------------------------------------------------------\n</code></pre>"},{"location":"examples/install.sandstorm.io.69/#code","title":"Code","text":"<pre><code>#! /bin/bash\n\n# This script installs the Sandstorm Personal Cloud Server on your Linux\n# machine. You can run the latest installer directly from the web by doing:\n#\n#     curl https://install.sandstorm.io | bash\n#\n# If `curl|bash` makes you uncomfortable, see other options here:\n#\n#     https://docs.sandstorm.io/en/latest/install/\n#\n# This script only modifies your system in the following ways:\n# - Install Sandstorm into the directory you choose, typically /opt/sandstorm.\n# - Optionally add an initscript or systemd service:\n#     /etc/init.d/sandstorm\n#     /etc/systemd/system/sandstorm.service\n# - Add commands \"sandstorm\" and \"spk\" to /usr/local/bin.\n#\n# Once installed, you may uninstall with the command: sandstorm uninstall\n#\n# The script will ask you whether you're OK with giving it root privileges.\n# If you refuse, the script can still install Sandstorm (to a directory you\n# own), but will not be able to install the initscript or shortcut commands,\n# and the dev tools will not work (due to limitations with using FUSE in a\n# sandbox).\n#\n# This script downloads and installs binaries. This means that to use this\n# script, you need to trust that the authors are not evil, or you must use\n# an isolated machine or VM. Of course, since the Sandstorm authors'\n# identities are widely known, if they did try to do anything evil, you\n# could easily get them arrested. That said, if you'd rather install from\n# 100% auditable source code, please check out the Github repository instead.\n#\n# All downloads occur over HTTPS from Sandstorm's servers and are further\n# verified using PGP.\n\nif test -z \"$BASH_VERSION\"; then\n  echo \"Please run this script using bash, not sh or any other shell.\" &gt;&amp;2\n  exit 1\nfi\n\n# We wrap the entire script in a big function which we only call at the very end, in order to\n# protect against the possibility of the connection dying mid-script. This protects us against\n# the problem described in this blog post:\n#   http://blog.existentialize.com/dont-pipe-to-your-shell.html\n_() {\n\nset -euo pipefail\n\n# Declare an array so that we can capture the original arguments.\ndeclare -a ORIGINAL_ARGS\n\n# Allow the environment to override curl's User-Agent parameter. We\n# use this to distinguish probably-actual-users installing Sandstorm\n# from the automated test suite, which invokes the install script with\n# this environment variable set.\nCURL_USER_AGENT=\"${CURL_USER_AGENT:-sandstorm-install-script}\"\n\n# Define I/O helper functions.\nerror() {\n  if [ $# != 0 ]; then\n    echo -en '\\e[0;31m' &gt;&amp;2\n    echo \"$@\" | (fold -s || cat) &gt;&amp;2\n    echo -en '\\e[0m' &gt;&amp;2\n  fi\n}\n\nfail() {\n  local error_code=\"$1\"\n  shift\n  if [ \"${SHOW_FAILURE_MSG:-yes}\" = \"yes\" ] ; then\n    echo \"*** INSTALLATION FAILED ***\" &gt;&amp;2\n    echo \"\"\n  fi\n  error \"$@\"\n  echo \"\" &gt;&amp;2\n\n  if [ \"$error_code\" = E_CURL_MISSING ] ; then\n    # There's no point in asking the user if they want to report an issue, since\n    # (1) there isn't one, they just need to install curl, and (2) doing so will\n    # fail anyway, since we use curl to send the report. We've already displayed\n    # the error, so just exit now.\n    exit 1\n  fi\n\n  # Users can export REPORT=no to avoid the error-reporting behavior, if they need to.\n  if [ \"${REPORT:-yes}\" = \"yes\" ] ; then\n    if USE_DEFAULTS=no prompt-yesno \"Hmm, installation failed. Would it be OK to send an anonymous error \nreport to the sandstorm.io team so we know something is wrong?\nIt would only contain this error code: $error_code\" \"yes\" ; then\n      echo \"Sending problem report...\" &gt;&amp;2\n      local BEARER_TOKEN=\"4-Og3Ty2SPmpkZGnVc_8hnBGXK0JBBXDeBn_55FWixJ\"\n      local API_ENDPOINT=\"https://alpha-api-df09d5faefd551337b59659de8ae7207.sandstorm.io\"\n      local HTTP_STATUS=$(\n        dotdotdot_curl \\\n          --silent \\\n          --max-time 20 \\\n          --data-binary \"{\\\"error_code\\\":\\\"$error_code\\\",\\\"user-agent\\\":\\\"$CURL_USER_AGENT\\\"}\" \\\n          -H \"Authorization: Bearer $BEARER_TOKEN\" \\\n          -X POST \\\n          --output \"/dev/null\" \\\n          -w '%{http_code}' \\\n          \"$API_ENDPOINT\")\n      if [ \"200\" == \"$HTTP_STATUS\" ] ; then\n        echo \"... problem reported successfully. Your installation did not succeed.\" &gt;&amp;2\n      elif [ \"000\" == \"$HTTP_STATUS\" ] ; then\n        error \"Submitting error report failed. Maybe there is a connectivity problem.\"\n      else\n        error \"Submitting error report resulted in strange HTTP status: $HTTP_STATUS\"\n      fi\n    else\n      echo \"Not sending report.\" &gt;&amp;2\n    fi\n    echo \"\"\n  fi\n  echo \"You can report bugs at: http://github.com/sandstorm-io/sandstorm\" &gt;&amp;2\n  exit 1\n}\n\nretryable_curl() {\n  # This function calls curl to download a file. If the file download fails, it asks the user if it\n  # is OK to retry.\n  local CURL_FAILED=\"no\"\n  curl -A \"${CURL_USER_AGENT}\" -f \"$1\" &gt; \"$2\" || CURL_FAILED=\"yes\"\n  if [ \"yes\" = \"${CURL_FAILED}\" ] ; then\n    if prompt-yesno \"Downloading $1 failed. OK to retry?\" \"yes\" ; then\n      echo \"\" &gt;&amp;2\n      echo \"Download failed. Waiting one second before retrying...\" &gt;&amp;2\n      sleep 1\n      retryable_curl \"$1\" \"$2\"\n    fi\n  fi\n}\n\ndotdotdot_curl() {\n  # This function calls curl, but first prints \"...\" to the screen, in\n  # an attempt to indicate to the user that the script is waiting on\n  # something.\n  #\n  # It then moves the cursor to the start of the line, so that future\n  # echo-ing will overwrite those dots.\n  #\n  # Since the script is -e, and in general we don't have a reliable\n  # thing that we do in the case that curl exits with a non-zero\n  # status code, we don't capture the status code; we allow the script\n  # to abort if curl exits with a non-zero status.\n\n  # Functions calling dotdotdot_curl expect to capture curl's own\n  # stdout. Therefore we do our echo-ing to stderr.\n\n  echo -n '...' &gt;&amp;2\n\n  curl \"$@\"\n\n  echo -ne '\\r' &gt;&amp;2\n}\n\nis_port_bound() {\n  local SCAN_HOST=\"$1\"\n  local SCAN_PORT=\"$2\"\n\n  if [ \"${DEV_TCP_USABLE}\" = \"unchecked\" ] ; then\n    REPORT=no fail \"E_DEV_TCP_UNCHECKED\" \"Programmer error. The author of install.sh used an uninitialized \nvariable.\"\n  fi\n\n  # We also use timeout(1) from coreutils to avoid this process taking a very long\n  # time in the case of e.g. weird network rules or something.\n  if [ \"${DEV_TCP_USABLE}\" = \"yes\" ] ; then\n    if timeout 1 bash -c \": &lt; /dev/tcp/${SCAN_HOST}/${SCAN_PORT}\" 2&gt;/dev/null; then\n      return 0\n    else\n      return 1\n    fi\n  fi\n\n  # If we are using a traditional netcat, then -z (zero i/o mode)\n  # works for scanning-type uses. (Debian defaults to this.)\n  #\n  # If we are using the netcat from the nmap package, then we can use\n  # --recv-only --send-only to get the same behavior. (Fedora defaults\n  # to this.)\n  #\n  # nc will either:\n  #\n  # - return true (exit 0) if it connected to the port, or\n  #\n  # - return false (exit 1) if it failed to connect to the port, or\n  #\n  # - return false (exit 1) if we are passing it the wrong flags.\n  #\n  # So if either if these invocations returns true, then we know the\n  # port is bound.\n  local DEBIAN_STYLE_INDICATED_BOUND=\"no\"\n  ${NC_PATH} -z \"$SCAN_HOST\" \"$SCAN_PORT\" &gt;/dev/null 2&gt;/dev/null &amp;&amp; DEBIAN_STYLE_INDICATED_BOUND=yes\n\n  if [ \"$DEBIAN_STYLE_INDICATED_BOUND\" == \"yes\" ] ; then\n      return 0\n  fi\n\n  # Not sure yet. Let's try the nmap-style way.\n  local NMAP_STYLE_INDICATED_BOUND=\"no\"\n  ${NC_PATH} --wait 1 --recv-only --send-only \"$SCAN_HOST\" \"$SCAN_PORT\" &gt;/dev/null 2&gt;/dev/null &amp;&amp; \\\n      NMAP_STYLE_INDICATED_BOUND=yes\n\n  if [ \"$NMAP_STYLE_INDICATED_BOUND\" == \"yes\" ] ; then\n      return 0\n  fi\n\n  # As far as we can tell, nmap can't connect to the port, so return 1\n  # to indicate it is not bound.\n  return 1\n}\n\n# writeConfig takes a list of shell variable names and saves them, and\n# their contents, to stdout. Therefore, the caller should redirect its\n# output to a config file.\nwriteConfig() {\n  while [ $# -gt 0 ]; do\n    eval echo \"$1=\\$$1\"\n    shift\n  done\n}\n\nprompt() {\n  local VALUE\n\n  # Hack: We read from FD 3 because when reading the script from a pipe, FD 0 is the script, not\n  #   the terminal. We checked above that FD 1 (stdout) is in fact a terminal and then dup it to\n  #   FD 3, thus we can input from FD 3 here.\n  if [ \"yes\" = \"$USE_DEFAULTS\" ] ; then\n    # Print the default.\n    echo \"$2\"\n    return\n  fi\n\n  # We use \"bold\", rather than any particular color, to maximize readability. See #2037.\n  echo -en '\\e[1m' &gt;&amp;3\n  echo -n \"$1 [$2]\" &gt;&amp;3\n  echo -en '\\e[0m ' &gt;&amp;3\n  read -u 3 VALUE\n  if [ -z \"$VALUE\" ]; then\n    VALUE=$2\n  fi\n  echo \"$VALUE\"\n}\n\nprompt-numeric() {\n  local NUMERIC_REGEX=\"^[0-9]+$\"\n  while true; do\n    local VALUE=$(prompt \"$@\")\n\n    if ! [[ \"$VALUE\" =~ $NUMERIC_REGEX ]] ; then\n      echo \"You entered '$VALUE'. Please enter a number.\" &gt;&amp;3\n    else\n      echo \"$VALUE\"\n      return\n    fi\n  done\n}\n\nprompt-yesno() {\n  while true; do\n    local VALUE=$(prompt \"$@\")\n\n    case $VALUE in\n      y | Y | yes | YES | Yes )\n        return 0\n        ;;\n      n | N | no | NO | No )\n        return 1\n        ;;\n    esac\n\n    echo \"*** Please answer \\\"yes\\\" or \\\"no\\\".\"\n  done\n}\n\n# Define global variables that the install script will use to mark its\n# own progress.\n\nUSE_DEFAULTS=\"no\"\nUSE_EXTERNAL_INTERFACE=\"no\"\nUSE_SANDCATS=\"no\"\nSANDCATS_SUCCESSFUL=\"no\"\nUSE_HTTPS=\"no\"\nCURRENTLY_UID_ZERO=\"no\"\nPREFER_ROOT=\"yes\"\nSHOW_MESSAGE_ABOUT_NEEDING_PORTS_OPEN=\"no\"\nSTARTED_SANDSTORM=\"no\"\n\n# Allow the test suite to override the path to netcat in order to\n# reproduce a compatibility issue between different nc versions.\nNC_PATH=\"${OVERRIDE_NC_PATH:-nc}\"\n\n# Allow install.sh to store if bash /dev/tcp works.\nDEV_TCP_USABLE=\"unchecked\"\n\n# Defaults for some config options, so that if the user requests no\n# prompting, they get these values.\nDEFAULT_DIR_FOR_ROOT=\"${OVERRIDE_SANDSTORM_DEFAULT_DIR:-/opt/sandstorm}\"\nDEFAULT_DIR_FOR_NON_ROOT=\"${OVERRIDE_SANDSTORM_DEFAULT_DIR:-${HOME:-opt}/sandstorm}\"\nDEFAULT_SMTP_PORT=\"30025\"\nDEFAULT_UPDATE_CHANNEL=\"dev\"\nDEFAULT_SERVER_USER=\"${OVERRIDE_SANDSTORM_DEFAULT_SERVER_USER:-sandstorm}\"\nSANDCATS_BASE_DOMAIN=\"${OVERRIDE_SANDCATS_BASE_DOMAIN:-sandcats.io}\"\nALLOW_DEV_ACCOUNTS=\"false\"\n\n# Define functions for each stage of the install process.\n\nusage() {\n  echo \"usage: $SCRIPT_NAME [-d] [-e] [-p PORT_NUMBER] [-u] [&lt;bundle&gt;]\" &gt;&amp;2\n  echo \"If &lt;bundle&gt; is provided, it must be the name of a Sandstorm bundle file,\" &gt;&amp;2\n  echo \"like 'sandstorm-123.tar.xz', which will be installed. Otherwise, the script\" &gt;&amp;2\n  echo \"downloads a bundle from the internet via HTTPS.\" &gt;&amp;2\n  echo '' &gt;&amp;2\n  echo 'If -d is specified, the auto-installs with defaults suitable for app development.' &gt;&amp;2\n  echo 'If -e is specified, default to listening on an external interface, not merely loopback.' &gt;&amp;2\n  echo 'If -i is specified, default to (i)nsecure mode where we do not request a HTTPS certificate.' &gt;&amp;2\n  echo 'If -p is specified, use its argument (PORT_NUMBER) as the default port for HTTP. Otherwise, use 6080. \nNote that if the install script enables HTTPS, it will use 443 instead!'\n  echo 'If -u is specified, default to avoiding root priviliges. Note that the dev tools only work if the \nserver has root privileges.' &gt;&amp;2\n  exit 1\n}\n\ndetect_current_uid() {\n  if [ $(id -u) = 0 ]; then\n    CURRENTLY_UID_ZERO=\"yes\"\n  fi\n}\n\ndisable_smtp_port_25_if_port_unavailable() {\n  PORT_25_AVAILABLE=\"no\"\n  if is_port_bound 0.0.0.0 25; then\n    return\n  fi\n  if is_port_bound 127.0.0.1 25; then\n    return\n  fi\n  PORT_25_AVAILABLE=\"yes\"\n}\n\ncheck_if_ports_unavailable() {\n  local PORT_80_AVAILABLE=\"no\"\n  is_port_bound 0.0.0.0 80 || PORT_80_AVAILABLE=\"yes\"\n\n  local PORT_443_AVAILABLE=\"no\"\n  is_port_bound 0.0.0.0 443 || PORT_443_AVAILABLE=\"yes\"\n\n  if [ \"$PORT_443_AVAILABLE\" == \"no\" -o \"$PORT_80_AVAILABLE\" == \"no\" ] ; then\n    SHOW_MESSAGE_ABOUT_NEEDING_PORTS_OPEN=\"yes\"\n  fi\n}\n\n\nhandle_args() {\n  SCRIPT_NAME=$1\n  shift\n\n  while getopts \":deiup:\" opt; do\n    case $opt in\n      d)\n        USE_DEFAULTS=\"yes\"\n        ;;\n      e)\n        USE_EXTERNAL_INTERFACE=\"yes\"\n        ;;\n      i)\n        # TODO(soon): Fix or remove this option, which currently does nothing\n        ;;\n      u)\n        PREFER_ROOT=no\n        ;;\n      p)\n        DEFAULT_PORT=\"${OPTARG}\"\n        ;;\n      *)\n        usage\n        ;;\n    esac\n  done\n\n  # If DEFAULT_PORT didn't get set above, set it to 6080 here.\n  DEFAULT_PORT=\"${DEFAULT_PORT:-6080}\"\n\n  # Keep a copy of the ORIGINAL_ARGS so that, when re-execing ourself,\n  # we can pass them in.\n  ORIGINAL_ARGS=(\"$@\")\n\n  # Pass positional parameters through\n  shift \"$((OPTIND - 1))\"\n\n  if [ $# = 1 ] &amp;&amp; [[ ! $1 =~ ^- ]]; then\n    BUNDLE_FILE=\"$1\"\n  elif [ $# != 0 ]; then\n    usage\n  fi\n}\n\nrerun_script_as_root() {\n  # Note: This function assumes that the caller has requested\n  # permission to use sudo!\n\n  # Pass $@ here to enable the caller to provide environment\n  # variables to bash, which will affect the execution plan of\n  # the resulting install script run.\n\n  # Remove newlines in $@, otherwise when we try to use $@ in a string passed\n  # to 'bash -c' the command gets cut off at the newline. ($@ contains newlines\n  # because at the call site we used escaped newlines for readability.)\n  local ENVVARS=$(echo $@)\n\n  # Add CURL_USER_AGENT to ENVVARS, since we always need to pass this\n  # through.\n  ENVVARS=\"$ENVVARS CURL_USER_AGENT=$CURL_USER_AGENT\"\n\n  if [ \"$(basename $SCRIPT_NAME)\" == bash ]; then\n    # Probably ran like \"curl https://sandstorm.io/install.sh | bash\"\n    echo \"Re-running script as root...\"\n\n    exec sudo bash -euo pipefail -c \"curl -fs -A $CURL_USER_AGENT https://install.sandstorm.io | $ENVVARS \nbash\"\n  elif [ \"$(basename $SCRIPT_NAME)\" == install.sh ] &amp;&amp; [ -e \"$0\" ]; then\n    # Probably ran like \"bash install.sh\" or \"./install.sh\".\n    echo \"Re-running script as root...\"\n    if [ ${#ORIGINAL_ARGS[@]} = 0 ]; then\n      exec sudo $ENVVARS bash \"$SCRIPT_NAME\"\n    else\n      exec sudo $ENVVARS bash \"$SCRIPT_NAME\" \"${ORIGINAL_ARGS[@]}\"\n    fi\n  fi\n\n  # Don't know how to run the script. Let the user figure it out.\n  REPORT=no fail \"E_CANT_SWITCH_TO_ROOT\" \"ERROR: This script could not detect its own filename, so could not \nswitch to root. \\\nPlease download a copy and name it 'install.sh' and run that as root, perhaps using sudo. \\\nTry this command:\n\ncurl https://install.sandstorm.io/ &gt; install.sh &amp;&amp; sudo bash install.sh\"\n}\n\nset_umask() {\n  # Use umask 0022, to minimize how much 'mkdir -m' we have to do, etc. See #2300.\n  umask 0022\n}\n\nassert_on_terminal() {\n  if [ \"no\" = \"$USE_DEFAULTS\" ] &amp;&amp; [ ! -t 1 ]; then\n    REPORT=no fail \"E_NO_TTY\" \"This script is interactive. Please run it on a terminal.\"\n  fi\n\n  # Hack: If the script is being read in from a pipe, then FD 0 is not the terminal input. But we\n  #   need input from the user! We just verified that FD 1 is a terminal, therefore we expect that\n  #   we can actually read from it instead. However, \"read -u 1\" in a script results in\n  #   \"Bad file descriptor\", even though it clearly isn't bad (weirdly, in an interactive shell,\n  #   \"read -u 1\" works fine). So, we clone FD 1 to FD 3 and then use that -- bash seems OK with\n  #   this.\n  exec 3&lt;&amp;1\n}\n\nassert_linux_x86_64() {\n  if [ \"$(uname)\" != Linux ]; then\n    fail \"E_NON_LINUX\" \"Sandstorm requires Linux. If you want to run Sandstorm on a Windows or\nMac system, you can use Vagrant or another virtualization tool. See our install documentation:\n\n- https://docs.sandstorm.io/en/latest/install/\"\n  fi\n\n  if [ \"$(uname -m)\" != x86_64 ]; then\n    fail \"E_NON_X86_64\" \"Sorry, the Sandstorm server currently only runs on x86_64 machines.\"\n  fi\n}\n\nassert_usable_kernel() {\n  KVERSION=( $(uname -r | grep -o '^[0-9.]*' | tr . ' ') )\n\n  if (( KVERSION[0] &lt; 3 || (KVERSION[0] == 3 &amp;&amp; KVERSION[1] &lt; 10) )); then\n    error \"Detected Linux kernel version: $(uname -r)\"\n    fail \"E_KERNEL_OLDER_THAN_310\" \"Sorry, your kernel is too old to run Sandstorm. We require kernel\" \\\n         \"version 3.10 or newer.\"\n  fi\n}\n\nmaybe_enable_userns_sysctl() {\n  # This function enables the Debian/Ubuntu-specific unprivileged\n  # userns sysctl, if the system has it and we want it.\n\n  if [ \"$USE_DEFAULTS\" != \"yes\" ] ; then\n    # Only do this when -d is passed. -d means \"use defaults suitable for app development\", and\n    # we want userns enabled for app development if possible since it enables UID randomization\n    # which helps catch app bugs. For the rest of the world, we're fine using the privileged\n    # sandbox instead.\n    return\n  fi\n\n  if [ \"no\" = \"$CURRENTLY_UID_ZERO\" ] ; then\n    # Not root. Can't do anything about it.\n    return\n  fi\n\n  if [ ! -e /proc/sys/kernel/unprivileged_userns_clone ]; then\n    # No such sysctl on this system.\n    return\n  fi\n\n  local OLD_VALUE=\"$(&lt; /proc/sys/kernel/unprivileged_userns_clone)\"\n\n  if [ \"$OLD_VALUE\" = \"1\" ]; then\n    # Already enabled.\n    return\n  fi\n\n  # Enable it.\n  if sysctl -wq kernel.unprivileged_userns_clone=1 2&gt;/dev/null; then\n    echo \"NOTE: Enabled unprivileged user namespaces because you passed -d.\"\n  else\n    # Apparently we can't. Maybe we're in a Docker container. Give up and use privileged sandbox.\n    return\n  fi\n\n  # Also make sure it is re-enabled on boot. If sysctl.d exists, we drop our own config in there.\n  # Otherwise we edit sysctl.conf, but that's less polite.\n  local SYSCTL_FILENAME=\"/etc/sysctl.conf\"\n  if [ -d /etc/sysctl.d ] ; then\n    SYSCTL_FILENAME=\"/etc/sysctl.d/50-sandstorm.conf\"\n  fi\n\n  if ! cat &gt;&gt; \"$SYSCTL_FILENAME\" &lt;&lt; __EOF__\n\n# Enable non-root users to create sandboxes (needed by Sandstorm).\nkernel.unprivileged_userns_clone = 1\n__EOF__\n  then\n    # We couldn't make the change permanent, so undo the change. Probably everything will work\n    # fine with the privileged sandbox. But if it doesn't, it's better that things fail now rather\n    # than wait for a reboot.\n    echo \"NOTE: Never mind, not enabling userns because can't write /etc/sysctl.d.\"\n    sysctl -wq \"kernel.unprivileged_userns_clone=$OLD_VALUE\" || true\n    return\n  fi\n}\n\ntest_if_dev_tcp_works() {\n  # In is_port_bound(), we prefer to use bash /dev/tcp to check if the port is bound. This is\n  # available on most Linux distributions, but it is a compile-time flag for bash and at least\n  # Debian historically disabled it.\n  #\n  # To test availability, we connect to localhost port 0, which is never available, hoping for a\n  # TCP-related error message from bash. We use a subshell here because we don't care that timeout\n  # will return false; we care if the grep returns false.\n  if (timeout 1 bash -c ': &lt; /dev/tcp/localhost/0' 2&gt;&amp;1 || true) | grep -q 'connect:' ; then\n    # Good! bash should get \"Connection refused\" on this, and this message is prefixed\n    # by the syscall it was trying to do, so therefore it tried to connect!\n    DEV_TCP_USABLE=\"yes\"\n  else\n    DEV_TCP_USABLE=\"no\"\n  fi\n}\n\nassert_dependencies() {\n  if [ -z \"${BUNDLE_FILE:-}\" ]; then\n    which curl &gt; /dev/null|| fail \"E_CURL_MISSING\" \"Please install curl(1). Sandstorm uses it to download \nupdates.\"\n  fi\n\n  # To find out if port 80 and 443 are available, we need a working bash /dev/net or `nc` on\n  # the path.\n  if [ \"${DEV_TCP_USABLE}\" = \"unchecked\" ] ; then\n    test_if_dev_tcp_works\n  fi\n  if [ \"${DEV_TCP_USABLE}\" = \"no\" ] ; then\n    which nc &gt; /dev/null || fail \"E_NC_MISSING\" \"Please install nc(1). (Package may be called \n'netcat-traditional' or 'netcat-openbsd'.)\"\n  fi\n\n  which tar &gt; /dev/null || fail \"E_TAR_MISSING\" \"Please install tar(1).\"\n  which xz &gt; /dev/null || fail \"E_XZ_MISSING\" \"Please install xz(1). (Package may be called 'xz-utils'.)\"\n}\n\nassert_valid_bundle_file() {\n  # ========================================================================================\n  # Validate bundle file, if provided\n\n  if [ -n \"${BUNDLE_FILE:-}\" ]; then\n    # Read the first filename out of the bundle, which should be the root directory name.\n    # We use \"|| true\" here because tar is going to SIGPIPE when `head` exits.\n    BUNDLE_DIR=$( (tar Jtf \"$BUNDLE_FILE\" || true) | head -n 1)\n    if [[ ! \"$BUNDLE_DIR\" =~ sandstorm-([0-9]+)/ ]]; then\n      fail \"E_INVALID_BUNDLE\" \"$BUNDLE_FILE: Not a valid Sandstorm bundle\"\n    fi\n\n    BUILD=${BASH_REMATCH[1]}\n\n    # We're going to change directory, so note the bundle's full name.\n    BUNDLE_FILE=$(readlink -f \"$BUNDLE_FILE\")\n  fi\n}\n\ndetect_init_system() {\n  # We start out by not knowing which init system is in use.\n  INIT_SYSTEM=\"unknown\"\n\n  # We look for systemd, since we have a nice way to generate a unit file.\n  if grep -q systemd /proc/1/comm; then\n    INIT_SYSTEM=\"systemd\"\n    return\n  fi\n\n  # We look for sysvinit, as a convenient fallback. Note that this\n  # should work fine with Upstart (on e.g. Ubuntu 14.04), too.\n  if [ -e /etc/init.d ]; then\n    INIT_SYSTEM=\"sysvinit\"\n    return\n  fi\n\n  # If we got this far, and we couldn't figure out the init system\n  # in use, that's life.\n}\n\nchoose_install_mode() {\n  echo -n 'Sandstorm makes it easy to run web apps on your own server. '\n\n  if [ \"yes\" = \"$USE_DEFAULTS\" ] ; then\n    CHOSEN_INSTALL_MODE=\"${CHOSEN_INSTALL_MODE:-development}\"  # dev server mode by default\n  fi\n\n  if [ \"no\" = \"${PREFER_ROOT:-}\" ] ; then\n    echo \"\"\n    echo \"NOTE: Showing you all options, including development options, but omitting \"\n    echo \"      init script automation, because you chose to install without using root.\"\n    CHOSEN_INSTALL_MODE=\"${CHOSEN_INSTALL_MODE:-development}\"  # dev server mode by default\n  fi\n\n  if [ -z \"${CHOSEN_INSTALL_MODE:-}\" ]; then\n    echo \"You can have:\"\n    echo \"\"\n    echo \"1. A typical install, to use Sandstorm (press enter to accept this default)\"\n    echo \"2. A development server, for working on Sandstorm itself or localhost-based app development\"\n    echo \"\"\n    CHOSEN_INSTALL_MODE=$(prompt-numeric \"How are you going to use this Sandstorm install?\" \"1\")\n  fi\n\n  if [ \"$CHOSEN_INSTALL_MODE\" = \"production\" ] || [ \"$CHOSEN_INSTALL_MODE\" = \"1\" ] ; then\n    assert_full_server_dependencies\n    full_server_install\n  else\n    dev_server_install\n  fi\n}\n\nassert_full_server_dependencies() {\n  # To set up sandcats, we need `openssl` on the path. Check for that,\n  # and if it is missing, bail out and tell the user they have to\n  # install it.\n  which openssl &gt; /dev/null|| fail \"E_OPENSSL_MISSING\" \"Please install openssl(1). Sandstorm uses it for the \nSandcats.io dynamic DNS service.\"\n}\n\ndev_server_install() {\n  # Use these settings for a dev-server-oriented install.\n  #\n  # Users will find themselves going through this flow if they\n  # manually choose a dev-server-related flow, but also if they pass\n  # -d on the command line. (The Vagrantfile and the test suite both\n  # use -d. The test suite runs install.sh with -d -u.)\n  #\n  # A \"dev server install\" must be run as root, unless you pass\n  # -u. That's because app development (aka spk dev) requires running\n  # as root, at the moment.\n\n  if [ \"yes\" = \"$PREFER_ROOT\" ] &amp;&amp; [ \"no\" = \"$CURRENTLY_UID_ZERO\" ] ; then\n    # We are not root, but we would like to be root.\n    echo \"If you want app developer mode for a Sandstorm install, you need root\"\n    echo \"due to limitations in the Linux kernel.\"\n    echo \"\"\n\n    echo \"To set up Sandstorm, we will use sudo to switch to root, then\"\n    echo \"provide further information before doing the install.\"\n    echo \"Sandstorm's database and web interface won't run as root.\"\n\n    # If we are running in USE_DEFAULTS mode, then it is not OK to ask\n    # for permission to use sudo.\n    if [ \"yes\" = \"$USE_DEFAULTS\" ] ; then\n      ACCEPTED_SUDO_FOR_DEV_SERVER=\"no\"\n    else\n      if prompt-yesno \"OK to continue?\" \"yes\" ; then\n        ACCEPTED_SUDO_FOR_DEV_SERVER=\"yes\"\n      else\n        ACCEPTED_SUDO_FOR_DEV_SERVER=\"no\"\n      fi\n    fi\n\n    if [ \"yes\" = \"$ACCEPTED_SUDO_FOR_DEV_SERVER\" ] ; then\n      rerun_script_as_root CHOSEN_INSTALL_MODE=development\n    else\n      # Print a message that allows people to make an informed decision.\n      SHOW_FAILURE_MSG=no REPORT=no fail \"E_NEED_ROOT\" \"\nOne development feature does require root. To install anyway, run:\n\ninstall.sh -u\n\nto install without using root access. In that case, Sandstorm will operate OK but package tracing ('spk dev') \nwill not work.\"\n    fi\n  fi\n\n  # If they did not pass -d, then let them opt into that, but only if\n  # PREFER_ROOT is still enabled.\n  #\n  # If they pass -u without -d, then they can answer the questions one\n  # by one.\n  if [ \"yes\" != \"$USE_DEFAULTS\" ] &amp;&amp; [ \"yes\" = \"$PREFER_ROOT\" ] ; then\n    echo \"We're going to:\"\n    echo \"\"\n    echo \"* Install Sandstorm in ${DEFAULT_DIR_FOR_ROOT}.\"\n    echo \"* Automatically keep Sandstorm up-to-date (with signed updates).\"\n    echo \"* Create a service user ($DEFAULT_SERVER_USER) that owns Sandstorm's files.\"\n    if [ -n \"${SUDO_USER:-}\" ]; then\n      echo \"* Add you ($SUDO_USER) to the $DEFAULT_SERVER_USER group so you can read/write app data.\"\n    fi\n    echo \"* Expose the service only on localhost aka local.sandstorm.io, not the public Internet.\"\n    echo \"* Enable 'dev accounts', for easy developer login.\"\n    if [ \"unknown\" == \"$INIT_SYSTEM\" ]; then\n      echo \"*** WARNING: Could not detect how to run Sandstorm at startup on your system. ***\"\n    else\n        echo \"* Configure Sandstorm to start on system boot (with $INIT_SYSTEM).\"\n    fi\n    echo \"* Listen for inbound email on port ${DEFAULT_SMTP_PORT}.\"\n    echo \"\"\n\n    if prompt-yesno \"Press enter to accept defaults. Type 'no' to customize.\" \"yes\" ; then\n      USE_DEFAULTS=\"yes\"\n    else\n      echo \"\"\n      echo \"OK. We will prompt you with every question.\"\n      echo \"\"\n    fi\n\n  fi\n\n  if [ \"yes\" = \"$USE_DEFAULTS\" ] ; then\n    # Use the default UPDATE_CHANNEL for auto-updates.\n    UPDATE_CHANNEL=\"$DEFAULT_UPDATE_CHANNEL\"\n\n    # Bind to localhost, unless -e specified in argv.\n    USE_EXTERNAL_INTERFACE=\"${USE_EXTERNAL_INTERFACE:-no}\"\n\n    # Use local.sandstorm.io as hostname unless environment variable declared otherwise. This\n    # short-circuits the code elsewhere that uses the system hostname if USE_EXTERNAL_INTERFACE is\n    # \"yes\".\n    SS_HOSTNAME=\"${SS_HOSTNAME:-local.sandstorm.io}\"\n\n    # Use 30025 as the default SMTP_LISTEN_PORT.\n    SMTP_LISTEN_PORT=\"${DEFAULT_SMTP_PORT}\"\n\n    # Start the service at boot, if we can.\n    START_AT_BOOT=\"yes\"\n\n    # Do not ask questions about our dynamic DNS service.\n    USE_SANDCATS=\"no\"\n\n    # Reasonable default ports.\n    PORT=\"${DEFAULT_PORT}\"\n\n    # Allow the mongo prompting part to determine a reasonable MONGO_PORT.\n\n    # Use the ALLOW_DEV_ACCOUNTS feature, which allows people to log\n    # into a Sandstorm instance without setting up any accounts.\n    ALLOW_DEV_ACCOUNTS=\"yes\"\n\n    # Do not bother setting a DESIRED_SERVER_USER. This way, the\n    # existing prompting will pick if this should be \"sandstorm\" (which\n    # it should be if we're running the install script as root) or the\n    # currently-logged-in user (which it should be if we're not root).\n\n    # Do not bother setting a DIR. This way, the existing prompting will\n    # pick between /opt/sandstorm and $HOME/sandstorm, depending on if\n    # the install is being done as root or not. It will use /opt/sandstorm\n    # in all cases if the script is run without the HOME environment variable.\n  fi\n}\n\nfull_server_install() {\n  # The full server install assumes you are OK with using root. If\n  # you're not, you should choose the development server and customize\n  # it to your heart's content.\n  if [ \"yes\" != \"${PREFER_ROOT}\" ] ; then\n    REPORT=no fail \"E_AUTO_NEEDS_SUDO\" \"The automatic setup process requires sudo. Try again with option 2, \ndevelopment server, to customize.\"\n  fi\n\n  if [ \"yes\" = \"$USE_DEFAULTS\" ] ; then\n    if [ -z \"${DESIRED_SANDCATS_NAME-}\" ] ; then\n      local MSG=\"For now, USE_DEFAULTS for full server installs requires a DESIRED_SANDCATS_NAME variable.\"\n      MSG=\"$MSG If you need support for non-sandcats full-server unattended installs, please file a bug.\"\n      fail \"E_USE_DEFAULTS_NEEDS_DESIRED_SANDCATS_NAME\" \"$MSG\"\n    else\n      if [ -z \"${SANDCATS_DOMAIN_RESERVATION_TOKEN:-}\" ] ; then\n        local MSG=\"When operating in USE_DEFAULTS mode, if you want a sandcats.io domain,\"\n        MSG=\"$MSG you must pre-reserve it before running this script. Specify it via the\"\n        MSG=\"$MSG SANDCATS_DOMAIN_RESERVATION_TOKEN environment variable.\"\n        fail \"E_USE_DEFAULTS_NEEDS_DESIRED_SANDCATS_NAME\" \"$MSG\"\n      fi\n    fi\n\n    # If they said USE_DEFAULTS then they don't need to be prompted.\n    ACCEPTED_FULL_SERVER_INSTALL=\"yes\"\n  fi\n\n  # Use port 25 for email, if we can. This logic only gets executed for \"full servers.\"\n  disable_smtp_port_25_if_port_unavailable\n  local PLANNED_SMTP_PORT=\"30025\"\n  if [ \"yes\" = \"$PORT_25_AVAILABLE\" ] ; then\n    PLANNED_SMTP_PORT=\"25\"\n  fi\n\n  if [ \"yes\" != \"${RERUNNING_AS_ROOT:-}\" ]; then\n    # Determine whether to show the ports unavailable warning\n    check_if_ports_unavailable\n\n    echo \"We're going to:\"\n    echo \"\"\n    echo \"* Install Sandstorm in $DEFAULT_DIR_FOR_ROOT\"\n    echo \"* Automatically keep Sandstorm up-to-date\"\n    echo \"* Configure auto-renewing HTTPS if you use a subdomain of sandcats.io\"\n    echo \"* Create a service user ($DEFAULT_SERVER_USER) that owns Sandstorm's files\"\n    if [ \"unknown\" == \"$INIT_SYSTEM\" ]; then\n      echo \"*** WARNING: Could not detect how to run Sandstorm at startup on your system. ***\"\n    else\n      echo \"* Configure Sandstorm to start on system boot (with $INIT_SYSTEM)\"\n    fi\n    echo \"* Listen for inbound email on port ${PLANNED_SMTP_PORT}.\"\n    echo \"\"\n\n    # If we're not root, we will ask if it's OK to use sudo.\n    if [ \"yes\" != \"$CURRENTLY_UID_ZERO\" ]; then\n      echo \"To set up Sandstorm, we will need to use sudo.\"\n    else\n      echo \"Rest assured that Sandstorm itself won't run as root.\"\n    fi\n\n    if [ -z \"${ACCEPTED_FULL_SERVER_INSTALL:-}\" ]; then\n      if prompt-yesno \"OK to continue?\" \"yes\"; then\n        ACCEPTED_FULL_SERVER_INSTALL=yes\n      else\n        ACCEPTED_FULL_SERVER_INSTALL=no\n      fi\n    fi\n\n    if [ \"yes\" = \"$ACCEPTED_FULL_SERVER_INSTALL\" ] &amp;&amp;\n      [ \"yes\" = \"$SHOW_MESSAGE_ABOUT_NEEDING_PORTS_OPEN\" ] ; then\n      echo \"\"\n      echo \"NOTE: It looks like your system already has some other web server installed\"\n      echo \"      (port 80 and/or 443 are taken), so Sandstorm cannot act as your main\"\n      echo \"      web server.\"\n      echo \"\"\n      echo \"      This script can set up Sandstorm to run on port $DEFAULT_PORT instead,\"\n      echo \"      without HTTPS. This makes sense if you're OK with typing the port number\"\n      echo \"      into your browser whenever you access Sandstorm and you don't need\"\n      echo \"      security. This also makes sense if you are going to set up a reverse proxy;\"\n      echo \"      if so, see https://docs.sandstorm.io/en/latest/administering/reverse-proxy/\"\n      echo \"\"\n      echo \"      If you want, you can quit this script with Ctrl-C now, and go uninstall\"\n      echo \"      your other web server, and then run this script again. It is also OK to\"\n      echo \"      proceed if you want.\"\n      echo \"\"\n      if ! prompt-yesno \"OK to skip automatic HTTPS setup &amp; bind to port $DEFAULT_PORT instead?\" \"yes\" ; then\n        fail \"E_USER_REFUSED_DEFAULT_PORT\" \"Exiting now. You can re-run the installer whenever you are ready.\"\n      fi\n    fi\n\n    # If they are OK continuing, and the script is not running as root\n    # at the moment, then re-run ourselves as root.\n    #\n    # Pass along enough information so that the script will keep\n    # executing smoothly, so the user doesn't have to re-answer\n    # questions.\n    if [ \"yes\" != \"$CURRENTLY_UID_ZERO\" ] ; then\n      if [ \"yes\" = \"$ACCEPTED_FULL_SERVER_INSTALL\" ] ; then\n        rerun_script_as_root CHOSEN_INSTALL_MODE=production \\\n                             ACCEPTED_FULL_SERVER_INSTALL=yes \\\n                             RERUNNING_AS_ROOT=yes \\\n                             DESIRED_SANDCATS_NAME=\"${DESIRED_SANDCATS_NAME:-}\" \\\n                             SANDCATS_REGISTRATION_EMAIL=\"${SANDCATS_REGISTRATION_EMAIL:-}\" \\\n                             ACME_EMAIL=\"${ACME_EMAIL:-}\" \\\n                             OVERRIDE_SANDCATS_BASE_DOMAIN=\"${OVERRIDE_SANDCATS_BASE_DOMAIN:-}\" \\\n                             OVERRIDE_SANDCATS_API_BASE=\"${OVERRIDE_SANDCATS_API_BASE:-}\" \\\n                             OVERRIDE_NC_PATH=\"${OVERRIDE_NC_PATH:-}\" \\\n                             OVERRIDE_SANDCATS_CURL_PARAMS=\"${OVERRIDE_SANDCATS_CURL_PARAMS:-}\"\n      fi\n\n      # If we're still around, it means they declined to run us as root.\n      echo \"\"\n      echo \"The automatic setup script needs root in order to:\"\n      echo \"* Create a separate user to run Sandstorm as, and\"\n      echo \"* Set up Sandstorm to start on system boot.\"\n      echo \"\"\n      fail \"E_DECLINED_AUTO_SETUP_DETAILS\" \"For a customized install, please re-run install.sh, and choose \noption (2) \"\\\n           \"to do a development install.\"\n    fi\n  fi\n\n  # Accepting this indicates a few things.\n  if [ \"yes\" = \"${ACCEPTED_FULL_SERVER_INSTALL}\" ]; then\n    UPDATE_CHANNEL=\"$DEFAULT_UPDATE_CHANNEL\"\n    DIR=\"$DEFAULT_DIR_FOR_ROOT\"\n    USE_EXTERNAL_INTERFACE=\"yes\"\n    USE_SANDCATS=\"yes\"\n    START_AT_BOOT=\"yes\"\n    DESIRED_SERVER_USER=\"$DEFAULT_SERVER_USER\"\n    PORT=\"${DEFAULT_PORT}\"\n    MONGO_PORT=\"6081\"\n    SMTP_LISTEN_PORT=\"${PLANNED_SMTP_PORT}\"\n  else\n    REPORT=no fail \"E_USER_WANTS_CUSTOM_SETTINGS\" \"If you prefer a more manual setup experience, try \ninstalling in development mode.\"\n  fi\n}\n\nsandcats_configure() {\n  # We generate the public key before prompting for a desired hostname\n  # so that when the user presses enter, we can try to register the\n  # hostname, and if that succeeds, we are totally done. This avoids a\n  # possible time-of-check-time-of-use race.\n  echo -n \"As a Sandstorm user, you are invited to use a free Internet hostname \"\n  echo \"as a subdomain of sandcats.io,\"\n  echo \"a service operated by the Sandstorm development team.\"\n\n  sandcats_generate_keys\n\n  echo \"\"\n  echo \"Sandcats.io protects your privacy and is subject to terms of use. By using it,\"\n  echo \"you agree to the terms of service &amp; privacy policy available here:\"\n  echo \"https://sandcats.io/terms https://sandcats.io/privacy\"\n  echo \"\"\n\n  # Having set up the keys, we run the function to register a name\n  # with Sandcats. This function handles tail-recursing itself until\n  # it succeeds and/or returning when the user expresses a desire to\n  # cancel the process.\n  sandcats_register_name\n}\n\nconfigure_hostnames() {\n  if [ \"yes\" = \"$USE_SANDCATS\" ] ; then\n    # If we're lucky, the user will be happy with the Sandcats\n    # hostname configuration. If not, then we'll have to actually\n    # prompt them.\n    sandcats_configure\n  fi\n\n  # Ask the user for port number information. (These functions\n  # optionally skip the questions if the details have already been\n  # filled in.)\n  choose_port\n  choose_mongo_port\n\n  # If we are supposed to use the external network interface, then\n  # configure the hostname and IP address accordingly.\n  if [ \"yes\" = \"$USE_EXTERNAL_INTERFACE\" ]; then\n    BIND_IP=0.0.0.0\n    SS_HOSTNAME=\"${SS_HOSTNAME:-$(hostname -f 2&gt;/dev/null || hostname)}\"\n  else\n    BIND_IP=127.0.0.1\n    SS_HOSTNAME=local.sandstorm.io\n    if [ \"yes\" != \"$USE_DEFAULTS\" ] ; then\n      echo \"Note: local.sandstorm.io maps to 127.0.0.1, i.e. your local machine.\"\n      echo \"For reasons that will become clear in the next step, you should use this\"\n      echo \"instead of 'localhost'.\"\n    fi\n  fi\n\n  # A typical server's DEFAULT_BASE_URL is its hostname plus port over HTTP. If the port is 80, then\n  # don't add it to BASE_URL to avoid triggering this bug:\n  # https://github.com/sandstorm-io/sandstorm/issues/2252\n  local PORT_SUFFIX=\"\"\n  if [ \"$PORT\" = \"80\" ] ; then\n    PORT_SUFFIX=\"\"\n  else\n    PORT_SUFFIX=\":${PORT}\"\n  fi\n\n  DEFAULT_BASE_URL=\"http://${SS_HOSTNAME}${PORT_SUFFIX}\"\n\n  if [ \"$USE_HTTPS\" = \"yes\" ]; then\n    DEFAULT_BASE_URL=\"https://$SS_HOSTNAME\"\n    HTTPS_PORT=443\n    PORT=80\n  fi\n\n  if [ \"yes\" = \"$SANDCATS_SUCCESSFUL\" ] ; then\n    # Do not prompt for BASE_URL configuration if Sandcats bringup\n    # succeeded.\n    BASE_URL=\"$DEFAULT_BASE_URL\"\n  else\n    BASE_URL=$(prompt \"URL users will enter in browser:\" \"$DEFAULT_BASE_URL\")\n    if ! [[ \"$BASE_URL\" =~ ^http(s?):// ]] ; then\n      local PROPOSED_BASE_URL=\"http://${BASE_URL}\"\n      echo \"** You entered ${BASE_URL}, which needs http:// at the front. I can use:\" &gt;&amp;2\n      echo \"        ${PROPOSED_BASE_URL}\" &gt;&amp;2\n      if prompt-yesno \"Is this OK?\" yes; then\n        BASE_URL=\"${PROPOSED_BASE_URL}\"\n      else\n        configure_hostnames\n      fi\n    fi\n  fi\n\n  # If the BASE_URL looks like localhost, then we had better use a\n  # DEFAULT_WILDCARD of local.sandstorm.io so that wildcard DNS works.\n  if [[ \"$BASE_URL\" =~ ^http://localhost(|:[0-9]*)(/.*)?$ ]]; then\n    DEFAULT_WILDCARD=*.local.sandstorm.io${BASH_REMATCH[1]}\n  elif [[ \"$BASE_URL\" =~ ^[^:/]*://([^/]*)/?$ ]]; then\n    DEFAULT_WILDCARD=\"${DEFAULT_WILDCARD:-*.${BASH_REMATCH[1]}}\"\n  else\n    DEFAULT_WILDCARD=\n  fi\n\n  # If we did the sandcats configuration, then we trust it to provide\n  # a working WILDCARD_HOST.\n  if [ \"yes\" = \"$SANDCATS_SUCCESSFUL\" ] ; then\n    WILDCARD_HOST=\"$DEFAULT_WILDCARD\"\n  else\n    if [ \"yes\" != \"$USE_DEFAULTS\" ] ; then\n      echo \"Sandstorm requires you to set up a wildcard DNS entry pointing at the server.\"\n      echo \"This allows Sandstorm to allocate new hosts on-the-fly for sandboxing purposes.\"\n      echo \"Please enter a DNS hostname containing a '*' which maps to your server. For \"\n      echo \"example, if you have mapped *.foo.example.com to your server, you could enter\"\n      echo \"\\\"*.foo.example.com\\\". You can also specify that hosts should have a special\"\n      echo \"prefix, like \\\"ss-*.foo.example.com\\\". Note that if your server's main page\"\n      echo \"is served over SSL, the wildcard address must support SSL as well, which\"\n      echo \"implies that you must have a wildcard certificate. For local-machine servers,\"\n      echo \"we have mapped *.local.sandstorm.io to 127.0.0.1 for your convenience, so you\"\n      echo \"can use \\\"*.local.sandstorm.io\\\" here. If you are serving off a non-standard\"\n      echo \"port, you must include it here as well.\"\n    fi\n    WILDCARD_HOST=$(prompt \"Wildcard host:\" \"$DEFAULT_WILDCARD\")\n\n    while ! [[ \"$WILDCARD_HOST\" =~ ^[^*]*[*][^*]*$ ]]; do\n      error \"Invalid wildcard host. It must contain exactly one asterisk.\"\n      WILDCARD_HOST=$(prompt \"Wildcard host:\" \"$DEFAULT_WILDCARD\")\n    done\n  fi\n}\n\nchoose_install_dir() {\n  if [ -z \"${DIR:-}\" ] ; then\n    local DEFAULT_DIR=\"$DEFAULT_DIR_FOR_ROOT\"\n    if [ \"yes\" != \"$CURRENTLY_UID_ZERO\" ] ; then\n      DEFAULT_DIR=\"$DEFAULT_DIR_FOR_NON_ROOT\"\n    fi\n\n    DIR=$(prompt \"Where would you like to put Sandstorm?\" \"$DEFAULT_DIR\")\n  fi\n\n  # Check for the existence of any partial Sandstorm installation. Note that by default, the\n  # Sandstorm uninstall process will retain $DIR/sandstorm.conf and $DIR/var. Since the install\n  # script can't reliably use those to preseed a new Sandstorm install, we still bail out in that\n  # situation.\n  if [ -e \"$DIR/sandstorm.conf\" ] || [ -e \"$DIR/var\" ] || [ -e \"$DIR/sandstorm\" ] ; then\n    # Clear the previous line, since in many cases, it's a \"echo -n\".\n    error \"\"\n    error \"This script is trying to install to ${DIR}.\"\n    error \"\"\n    error \"You seem to already have a ${DIR} directory with a Sandstorm installation inside. You should \neither:\"\n    error \"\"\n    error \"1. Reconfigure that Sandstorm install using its configuration file -- ${DIR}/sandstorm.conf -- or \nthe admin interface. See docs at:\"\n    error \"https://docs.sandstorm.io/en/latest/administering/\"\n    error \"\"\n    error \"2. Uninstall Sandstorm before attempting to perform a new install. Even if you created a \nsandcats.io hostname, it is safe to uninstall so long as you do not need the data in your Sandstorm install. \nWhen you re-install Sandstorm, you can follow a process to use the old hostname with the new install. See \nuninstall docs at:\"\n    error \"https://docs.sandstorm.io/en/latest/install/#uninstall\"\n    error \"\"\n    error \"3. Use a different target directory for the new Sandstorm install. Try running install.sh with the \n-d option.\"\n    error \"\"\n    error \"4. Retain your data, but restore your Sandstorm code and configuration to a fresh copy. To do \nthat, keep a backup  of ${DIR}/var and then do a fresh install; stop the Sandstorm service, and restore your \nbackup of ${DIR}/var. You may need to adjust permissions after doing that.\"\n    REPORT=no fail \"E_DIR_ALREADY_EXISTS\" \"Please try one of the above. Contact \nhttps://groups.google.com/d/forum/sandstorm-dev for further help.\"\n  fi\n\n  mkdir -p \"$DIR\"\n  cd \"$DIR\"\n}\n\nchoose_smtp_port() {\n  # If SMTP_LISTEN_PORT is already decided, then don't bother asking.\n  if [ ! -z \"${SMTP_LISTEN_PORT:-}\" ] ; then\n    return\n  fi\n\n  local REQUESTED_SMTP_PORT=$(prompt-numeric \"Sandstorm grains can receive email. What port should Sandstorm \nlisten on, for inbound SMTP?\" \"${DEFAULT_SMTP_PORT}\")\n  if [ -z \"${REQUESTED_SMTP_PORT}\" ] ; then\n    choose_smtp_port\n  else\n    SMTP_LISTEN_PORT=\"${REQUESTED_SMTP_PORT}\"\n  fi\n}\n\nload_existing_settings() {\n  # If there is no settings file to load, then we can skip the\n  # rest of this function.\n  if [ ! -e sandstorm.conf ]; then\n    return\n  fi\n\n  echo \"Found existing sandstorm.conf. Using it.\"\n  . sandstorm.conf\n  if [ \"${SERVER_USER:+set}\" != set ]; then\n    fail \"E_CONF_DOES_NOT_SET_SERVER_USER\" \"Existing config does not set SERVER_USER. Please fix or delete \nit.\"\n  fi\n\n  # If sandstorm.conf specifies an UPDATE_CHANNEL, then make that be\n  # the default. Additionally, because UPDATE_CHANNEL is already\n  # set, the part of the code that prompts the user about what\n  # UPDATE_CHANNEL they want should skip itself.\n  if [ \"${UPDATE_CHANNEL:-none}\" != none ]; then\n    DEFAULT_UPDATE_CHANNEL=$UPDATE_CHANNEL\n  fi\n}\n\nchoose_server_user_if_needed() {\n  # If there is already a sandstorm.conf, we assume that it has a\n  # SERVER_USER set and that the user exists. This is a\n  # basically-reasonable assumption, given that\n  # load_existing_settings() verifies that there is a SERVER_USER set.\n  if [ -e sandstorm.conf ] ; then\n    return\n  fi\n\n  # If we are not root, then life is easy; we run Sandstorm as the current\n  # user.\n  if [ \"yes\" != \"$CURRENTLY_UID_ZERO\" ]; then\n    SERVER_USER=$(id -un)\n    return\n  fi\n\n  # If previous configuration (e.g. easy-configuration, option 1) requested a\n  # specific SERVER_USER, then let's go with that.\n  if [ ! -z \"${DESIRED_SERVER_USER:-}\" ] ; then\n    SERVER_USER=\"$DESIRED_SERVER_USER\"\n    CREATE_SERVER_USER=\"yes\"\n    ADD_SUDO_USER_TO_SERVER_GROUP=\"no\"\n    return\n  fi\n\n  # If we got this far, then we need to ask.\n  SERVER_USER=$(prompt \"Local user account to run server under:\" sandstorm)\n\n  while [ \"$SERVER_USER\" = root ]; do\n    echo \"Sandstorm cannot run as root!\"\n    SERVER_USER=$(prompt \"Local user account to run server under:\" sandstorm)\n  done\n}\n\ncreate_server_user_if_needed() {\n  # Find out if the user exists. If so, then we're done!\n  if id \"$SERVER_USER\" &gt; /dev/null 2&gt;&amp;1; then\n    return\n  fi\n\n  # Since the server user does not exist, we create it (asking for\n  # permission if necessary).\n  if [ \"yes\" != \"${CREATE_SERVER_USER:-}\" ] ; then\n    if prompt-yesno \"User account '$SERVER_USER' doesn't exist. Create it?\" yes ; then\n      CREATE_SERVER_USER=yes\n    fi\n  fi\n\n  # If people don't want us to create it, then let's bail now.\n  if [ \"yes\" != \"${CREATE_SERVER_USER:-}\" ] ; then\n    return\n  fi\n\n  # OK! Let's proceed.\n  #\n  # To create the server user, we first try `useradd`, which is widely available on most\n  # distros. If that isn't available, it's likely we're running on a busybox based system.\n  # busybox provides an `adduser` applet, so if that command links to the busybox binary\n  # we it instead.\n  #\n  # Note that debian provides an `adduser` command as well, but its usage is different.\n  # useradd is available on debian anyway, so we'll end up using that.\n  if which useradd &gt;/dev/null; then\n    # Per the man page for useradd, USERGROUPS_ENAB in /etc/login.defs controls if useradd\n    # will automatically create a group for this user (the new group would have the same\n    # name as the new user). On systems such as OpenSuSE where that flag is set to false\n    # by default, or on systems where the administrator has personally tuned that flag,\n    # we need to provide --user-group to useradd so that it creates the group.\n    useradd --system --user-group \"$SERVER_USER\"\n  elif [ \"$(basename $(readlink $(which adduser)))\" = busybox ]; then\n    # With busybox we need to separately create the user's group.\n    addgroup -S \"$SERVER_USER\"\n    adduser -S -G \"$SERVER_USER\" \"$SERVER_USER\"\n  else\n    fail \"E_NO_USERADD\" \\\n      \"Couldn't find a command with which to add a user (either useradd or busybox).\"\n  fi\n\n  echo \"Note: Sandstorm's storage will only be accessible to the group '$SERVER_USER'.\"\n\n  # If SUDO_USER is non-empty, we let the user opt in to adding\n  # themselves to the storage group.\n\n  # The easy-install opts out of this flow by setting\n  # ADD_SUDO_USER_TO_SERVER_GROUP=no.\n  if [ \"no\" = \"${ADD_SUDO_USER_TO_SERVER_GROUP:-}\" ] ; then\n    return\n  fi\n\n  if [ -n \"${SUDO_USER:-}\" ]; then\n    if prompt-yesno \"Add user '$SUDO_USER' to group '$SERVER_USER'?\" no ; then\n      usermod -a -G \"$SERVER_USER\" \"$SUDO_USER\"\n      echo \"Added. Don't forget that group changes only apply at next login.\"\n    fi\n  fi\n}\n\nchoose_port() {\n  # If there already is a PORT chosen, then don't bother asking.\n  if [ ! -z \"${PORT:-}\" ] ; then\n    return\n  fi\n\n  PORT=$(prompt-numeric \"Server main HTTP port:\" $DEFAULT_PORT)\n\n  while [ \"$PORT\" -lt 1024 ]; do\n    echo \"Ports below 1024 require root privileges. Sandstorm does not run as root.\"\n    echo \"To use port $PORT, you'll need to set up a reverse proxy like nginx that \"\n    echo \"forwards to the internal higher-numbered port. The Sandstorm git repo \"\n    echo \"contains an example nginx config for this.\"\n    PORT=$(prompt-numeric \"Server main HTTP port:\" $DEFAULT_PORT)\n  done\n}\n\nchoose_mongo_port() {\n  # If there is already a MONGO_PORT chosen, then don't bother asking.\n  if [ ! -z \"${MONGO_PORT:-}\" ] ; then\n    return\n  fi\n\n  # If the port we'll bind is less than 1024, then default to MONGO_PORT of 6081 because\n  # mongo can't listen on root-owned ports in our configuration.\n  local DEFAULT_MONGO_PORT=\"$((PORT + 1))\"\n  if [ \"$PORT\" -lt 1024 ] ; then\n    DEFAULT_MONGO_PORT=\"6081\"\n  fi\n\n  MONGO_PORT=$(prompt-numeric \"Database port (choose any unused port):\" \"${DEFAULT_MONGO_PORT}\")\n}\n\nchoose_external_or_internal() {\n  # Figure out if we want to listen on internal vs. external interfaces.\n  if [ \"yes\" != \"$USE_EXTERNAL_INTERFACE\" ]; then\n    if prompt-yesno \"Expose to localhost only?\" yes ; then\n      USE_EXTERNAL_INTERFACE=\"no\"\n    else\n      USE_EXTERNAL_INTERFACE=\"yes\"\n    fi\n  fi\n}\n\nconfigure_auto_updates() {\n  # If UPDATE_CHANNEL is non-empty, then skip this.\n  if [ -n \"${UPDATE_CHANNEL:-}\" ]; then\n    return\n  fi\n\n  # Otherwise, ask!\n  if prompt-yesno \"Automatically keep Sandstorm updated?\" yes; then\n    UPDATE_CHANNEL=$DEFAULT_UPDATE_CHANNEL\n  else\n    UPDATE_CHANNEL=none\n  fi\n}\n\nconfigure_dev_accounts() {\n  # If ALLOW_DEV_ACCOUNTS is set to yes already, then skip this.\n  if [ \"yes\" = \"${ALLOW_DEV_ACCOUNTS}\" ]; then\n    return\n  fi\n\n  # If USE_EXTERNAL_INTERFACE is set to yes, then skip this, because\n  # dev accounts on the Internet would be crazy.\n  if [ \"yes\" = \"${USE_EXTERNAL_INTERFACE}\" ] ; then\n    return\n  fi\n\n  echo \"Sandstorm supports 'dev accounts', a feature that lets anyone log in\"\n  echo \"as admin and other sample users to a Sandstorm server. We recommend\"\n  echo \"it for app development, and absolutely do not recommend it for\"\n  echo \"a server on the public Internet.\"\n\n  if prompt-yesno \"Enable dev accounts?\" \"yes\" ; then\n    ALLOW_DEV_ACCOUNTS=yes\n  fi\n}\n\nsave_config() {\n  writeConfig SERVER_USER PORT MONGO_PORT BIND_IP BASE_URL WILDCARD_HOST UPDATE_CHANNEL ALLOW_DEV_ACCOUNTS \nSMTP_LISTEN_PORT &gt; sandstorm.conf\n  if [ \"yes\" = \"$SANDCATS_SUCCESSFUL\" ] ; then\n    writeConfig SANDCATS_BASE_DOMAIN &gt;&gt; sandstorm.conf\n  fi\n  if [ \"yes\" = \"$USE_HTTPS\" ] ; then\n    writeConfig HTTPS_PORT &gt;&gt; sandstorm.conf\n  fi\n\n  echo\n  echo \"Config written to $PWD/sandstorm.conf.\"\n}\n\ndownload_latest_bundle_and_extract_if_needed() {\n  # If BUNDLE_FILE is non-empty, we were provided a bundle file, so we\n  # can skip downloading one.\n  if [ -n \"${BUNDLE_FILE:-}\" ]; then\n    return\n  fi\n\n  echo \"Finding latest build for $DEFAULT_UPDATE_CHANNEL channel...\"\n  # NOTE: The type is install_v2. We use the \"type\" value when calculating how many people attempted\n  # to do a Sandstorm install. We had to stop using \"install\" because vagrant-spk happens to use\n  # &amp;type=install during situations that we do not want to categorize as an attempt by a human to\n  # install Sandstorm.\n  BUILD=\"$(curl -A \"$CURL_USER_AGENT\" -fs \n\"https://install.sandstorm.io/$DEFAULT_UPDATE_CHANNEL?from=0&amp;type=install_v2\")\"\n  BUILD_DIR=\"sandstorm-${BUILD}\"\n\n  if [[ ! \"$BUILD\" =~ ^[0-9]+$ ]]; then\n    fail \"E_INVALID_BUILD_NUM\" \"Server returned invalid build number: $BUILD\"\n  fi\n\n  do-download() {\n    rm -rf \"${BUILD_DIR}\"\n    WORK_DIR=\"$(mktemp -d ./sandstorm-installer.XXXXXXXXXX)\"\n    local URL=\"https://dl.sandstorm.io/sandstorm-$BUILD.tar.xz\"\n    echo \"Downloading: $URL\"\n    retryable_curl \"$URL\" \"$WORK_DIR/sandstorm-$BUILD.tar.xz\"\n    retryable_curl \"$URL.sig\" \"$WORK_DIR/sandstorm-$BUILD.tar.xz.sig\"\n\n    if which gpg &gt; /dev/null; then\n      export GNUPGHOME=\"$WORK_DIR/.gnupg\"\n      mkdir -m 0700 -p \"$GNUPGHOME\"\n\n      # Regenerate with: gpg --armor --export 160D2D577518B58D94C9800B63F227499DA8CCBD\n      gpg --dearmor &gt; \"$WORK_DIR/sandstorm-keyring.gpg\" &lt;&lt; __EOF__\n-----BEGIN PGP PUBLIC KEY BLOCK-----\nVersion: GnuPG v1\n\nmQENBFX8ypkBCAC8sjX5yZqKdW8nY7aE/GpVeS+qSCbpYSJwixYNFXbz3MQihR3S\nsuvg5uw1KyuQb23c0LwirfxazVf7txKhQNaNU3ek62LG3wcGeBrvQGsIUMbkatay\n/163CLeVWfSK1Z4pFc4dhdjXYSOz0oZxd7Mp78crBbGKmyn7PtzdAqt+XfEXNuee\ncDbx++P57n5s5xc5fQWznt333IMgmgTREGUROfh4kL376rFAS208XIywJlUVkoKM\nkIzgcjevFGwYKdsLigHXCDp9toQHl8oPjFV+RE8Br8ciJlMp9CqCfHGwj0Orxasc\ne9moLqqUc+iKdg9bQfuAbJ/jFNhGmV/CVv9tABEBAAG0LlNhbmRzdG9ybS5pbyAo\ncmVsZWFzZXMpIDxzdXBwb3J0QHNhbmRzdG9ybS5pbz6JATgEEwECACIFAlX8ypkC\nGwMGCwkIBwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEGPyJ0mdqMy91bYH/iTg9qbw\nG3th57Yf70NtyMJE3UBFDYDNAgT45UBEHoHhQM5cdFu/EIHggOKl/A2zL19Nh555\n5F5o3jiJChQ0cvpoVnDdA5lRKD9iK6hzAba9fCVAx/od1PULQP7KV+uHTQuclSFO\nDBvpgT8bMY9LmlpTl+l2lvYd+c50w3jZMFwh8JrJYAc3X0kBfVEywVZkjH8Nw5nD\nv/j5Of3XXfEg84tNyWSYUMrYVORJyfHtA9e3JXNv5BMxH73AVLnyCJhCaodQsC6Z\nhFkHUvvRb58ZqKXMtLYTd/8XLIvpkgRNX6EHWDslJh3BaBwHSuqDNssh1TW5xPjA\n9vkPDzeZfLkuxpy5AQ0EVfzKmQEIANyi22M/3KhkghsPA6Rpha1lx6JJCb4p7E21\ny82OGFUwcMpZkSgh1lARgp/Mvc2CHhAXi6NkGbgYc1q5rgARSvim2EMZNQOEqRb9\nteEeI3w7Nz8Q/WoWck9WaXg8EdELtBOXYgVEirVddUl6ftUvCeBh3hE2Y/CLQSXL\nCYXdQ2/MN6xV8tepuWOu0aPxxPUNea9ceDNZ8/CXEL32pzv9SUX/3KgSnFTzmxNP\nthzXGuaAQGMZRu3cdTSeK9UUX4L3lxv7p0nE/2K18MU3FayTJqspfUCc4BgHZRMN\nsh+2/YNfJgi0uWex1WnU94ZIp4A0uic54bU1ZECSwxg81KHaEEkAEQEAAYkBHwQY\nAQIACQUCVfzKmQIbDAAKCRBj8idJnajMvZgPB/0THpTPnfsYNkwQrBsrTq413ZTF\nJmVyeZ9xnGDImOdyHhGLlnLC1YEnaNUVEyMKifya4TF2utrLrsMT9TC/dWvFsYlJ\noMcUpaSlrFoAoPp3pdOGCIRYNhWGHoxy0Ti1WAa/6A+GoHJpUEz85/jD4vjgYlCX\nZFW1Pji9PbdIZFZQR4FyYBkkZOUq6yyTNR0syQPVy3EsPVvXzszm2zV/1YjGymgj\nMKeYR9+VU+PlFAY9wwLWLTFeSzxTyVjbPwF5bWHV32GM8g0/NgA6a1JLL40v7pqf\nuYvFk2KJpo3gZNGJ72gLkSzie7Eu1/V67JIG9TwfrJUEj8Uwd5zPv1MOqfWl\n=OiS5\n-----END PGP PUBLIC KEY BLOCK-----\n__EOF__\n\n      if gpg --no-default-keyring --keyring $WORK_DIR/sandstorm-keyring.gpg --status-fd 1 \\\n             --verify $WORK_DIR/sandstorm-$BUILD.tar.xz{.sig,} 2&gt;/dev/null | \\\n          grep -q '^\\[GNUPG:\\] VALIDSIG 160D2D577518B58D94C9800B63F227499DA8CCBD '; then\n        echo \"GPG signature is valid.\"\n      else\n        rm -rf sandstorm-$BUILD\n        fail \"E_INVALID_GPG_SIG\" \"GPG signature is NOT valid! Please report to security@sandstorm.io \nimmediately!\"\n      fi\n\n      unset GNUPGHOME\n    else\n      echo \"WARNING: gpg not installed; not verifying signatures (but it's HTTPS so you're probably fine)\" &gt;&amp;2\n    fi\n\n    tar Jxof \"$WORK_DIR/sandstorm-$BUILD.tar.xz\"\n    rm -rf \"$WORK_DIR\"\n\n    if [ ! -e \"$BUILD_DIR\" ]; then\n      fail \"E_BAD_PACKAGE\" \"Bad package -- did not contain $BUILD_DIR directory.\"\n    fi\n\n    # We used to reject packages older than 30 days on the assumption the package would definitely\n    # be updated more often than that. For about six years the existence of this check was the main\n    # thing that drove me (Kenton) to do a release every month, although I occasionally forgot which\n    # would temporarily block new installs. Surprisingly (to me, at least), whenever this happend,\n    # people would actually notice and complain within a day or two -- people were apparently\n    # still installing Sandstorm regularly.\n    #\n    # As of Feb 2023, though, I think it's time to retire this check and end the monthly update\n    # schedule, for several reasons:\n    # - In 2022, the majority of months saw no actual changes at all.\n    # - Ian, who had been the most active maintainer, is now focusing his efforts on a new\n    #   implementation called Tempest. So 2023 is likely to see even fewer changes.\n    # - It's no longer possible to update the Meteor dependency, because newer versions of Meteor\n    #   no longer support the ancient version of Mongo we're stuck on (2.6), and writing automation\n    #   to update everyone's Mongo instances automatically without breaking anyone is too large\n    #   a project for anyone to volunteer for. Since almost all of Sandstorm's dependencies stem\n    #   from Meteor, trying to update dependencies on a monthly basis has become futile, as the\n    #   pinned Meteor version holds everything else back.\n    # - I just have too much to do, and although releases are not a whole lot of work, it feels\n    #   like one more thing on the pile.\n    #\n    # I'm still happy to push releases when there are interesting changes.\n#    if [ ! -e \"$BUILD_DIR/buildstamp\" ] || \\\n#       [ $(stat -c %Y \"$BUILD_DIR/buildstamp\") -lt $(( $(date +%s) - 30*24*60*60 )) ]; then\n#      rm -rf \"$BUILD_DIR\"\n#      fail \"E_PKG_STALE\" \"The downloaded package seems to be more than a month old. Please verify that your\" \n\\\n#           \"computer's clock is correct and try again. It could also be that an attacker is\" \\\n#           \"trying to trick you into installing an old version. Please contact\" \\\n#           \"security@sandstorm.io if the problem persists.\"\n#    fi\n  }\n\n  if [ -e $BUILD_DIR ]; then\n    echo \"$BUILD_DIR is already present. Should I use it or re-download?\"\n    if ! prompt-yesno \"Use existing copy?\" yes; then\n      do-download\n    fi\n  else\n    do-download\n  fi\n}\n\nextract_bundle_if_provided() {\n  # If BUNDLE_FILE is empty, it means that we have no bundle file to extract,\n  # so we can skip downloading it.\n  if [ -z \"${BUNDLE_FILE:-}\" ]; then\n    return\n  fi\n\n  # Use the specified local bundle, which we already validated earlier.\n\n  if [ $BUILD = 0 ]; then\n    BUILD_DIR=sandstorm-custom.$(date +'%Y-%m-%d_%H-%M-%S')\n  else\n    BUILD_DIR=sandstorm-$BUILD\n  fi\n\n  rm -rf \"$BUILD_DIR\"\n  mkdir \"$BUILD_DIR\"\n  (cd \"$BUILD_DIR\" &amp;&amp; tar Jxof \"$BUNDLE_FILE\" --strip=1)\n}\n\nmake_runtime_directories() {\n  GROUP=$(id -g $SERVER_USER)\n\n  # Make var directories.\n  mkdir -p var/{log,pid,mongo} var/sandstorm/{apps,grains,downloads}\n\n  # Create useful symlinks.\n  ln -sfT $BUILD_DIR latest\n  ln -sfT latest/sandstorm sandstorm\n}\n\nset_permissions() {\n  # If not running the installer as root, we can't do all the\n  # permissions stuff we want to.\n  if [ \"yes\" != \"$CURRENTLY_UID_ZERO\" ]; then\n    return\n  fi\n\n  local ADMIN_TOKEN_PATH=\n  if [ -e \"${ADMIN_TOKEN_PATH}\" ] ; then\n    ADMIN_TOKEN_PATH=\"var/sandstorm/adminToken\"\n  fi\n\n  # Set ownership of files.  We want the dirs to be root:sandstorm but the contents to be\n  # sandstorm:sandstorm.\n  chown -R $SERVER_USER:$GROUP var/{log,pid,mongo} var/sandstorm/{apps,grains,downloads} $ADMIN_TOKEN_PATH\n  chown root:$GROUP var/{log,pid,mongo,sandstorm} var/sandstorm/{apps,grains,downloads} $ADMIN_TOKEN_PATH\n  chmod -R g=rwX,o= var/{log,pid,mongo,sandstorm} var/sandstorm/{apps,grains,downloads} $ADMIN_TOKEN_PATH\n}\n\ninstall_sandstorm_symlinks() {\n  # If not running the installer as root, we can't modify\n  # /usr/local/bin, so we have to skip this.\n  if [ \"yes\" != \"$CURRENTLY_UID_ZERO\" ]; then\n    return\n  fi\n\n  local FAILED_TO_WRITE_SYMLINK=\"no\"\n\n  # Install tools.\n  ln -sfT $PWD/sandstorm /usr/local/bin/sandstorm || FAILED_TO_WRITE_SYMLINK=yes\n  ln -sfT $PWD/sandstorm /usr/local/bin/spk || FAILED_TO_WRITE_SYMLINK=yes\n\n  # If /usr/local/bin is not actually writeable, even though we are root, then bail on this for now.\n  # That can happen on e.g. CoreOS; see https://github.com/sandstorm-io/sandstorm/issues/1660\n  # the bash \"-w\" does not detect read-only mounts, so we use a behavior check above.\n  if [ \"${FAILED_TO_WRITE_SYMLINK}\" = \"yes\" ] ; then\n    echo \"\"\n    echo \"*** WARNING: /usr/local/bin was not writeable. To run sandstorm or spk manually, use:\"\n    echo \" - $PWD/sandstorm\"\n    echo \" - $PWD/sandstorm spk\"\n    echo \"\"\n    return\n  fi\n\n}\n\nask_about_starting_at_boot() {\n  # Starting Sandstorm at boot cannot work if we are not root by this point.\n  if [ \"$CURRENTLY_UID_ZERO\" != \"yes\" ] ; then\n    START_AT_BOOT=\"no\"\n  fi\n\n  # If we already know if we want to start the thing at boot, we can skip asking.\n  if [ ! -z \"${START_AT_BOOT:-}\" ] ; then\n    return\n  fi\n\n  if prompt-yesno \"Start sandstorm at system boot (using $INIT_SYSTEM)?\" yes; then\n    START_AT_BOOT=yes\n  fi\n}\n\nconfigure_start_at_boot_if_desired() {\n  SANDSTORM_NEEDS_TO_BE_STARTED=\"yes\"\n\n  # If the user doesn't want us to start Sandstorm at boot, then we\n  # don't run anything in this function.\n  if [ \"yes\" != \"${START_AT_BOOT:-}\" ] ; then\n    return\n  fi\n\n  if [ \"systemd\" = \"${INIT_SYSTEM}\" ] ; then\n    configure_systemd_init_system\n    SANDSTORM_NEEDS_TO_BE_STARTED=no\n  elif [ \"sysvinit\" = \"${INIT_SYSTEM}\" ] ; then\n    configure_sysvinit_init_system\n    SANDSTORM_NEEDS_TO_BE_STARTED=no\n  else\n    echo \"Note: I don't know how to set up sandstorm to auto-run at startup on\"\n    echo \"  your system. :(\"\n    echo\n  fi\n}\n\nconfigure_systemd_init_system() {\n  # WARNING: This function should only be run if we already know\n  # systemd is the current init system. It relies on its caller to\n  # verify that.\n\n  local SYSTEMD_UNIT=\"sandstorm.service\"\n\n  # Stop Sandstorm if it is currently running.\n  if systemctl list-unit-files | grep -q $SYSTEMD_UNIT; then\n    systemctl stop sandstorm || true\n  fi\n\n  # the init.d logic simply overwrites the init script if it exists, adopt that here\n  for SYSTEMD_UNIT_PATH in /etc/systemd/system /run/systemd/system /usr/lib/systemd/system; do\n    if [ -e $SYSTEMD_UNIT_PATH/$SYSTEMD_UNIT ] ; then\n      rm $SYSTEMD_UNIT_PATH/$SYSTEMD_UNIT\n    fi\n  done\n\n  cat &gt; /etc/systemd/system/$SYSTEMD_UNIT &lt;&lt; __EOF__\n[Unit]\nDescription=Sandstorm server\nAfter=local-fs.target remote-fs.target network-online.target\nRequires=local-fs.target remote-fs.target\nWants=network-online.target\n\n[Service]\nType=forking\nExecStart=$PWD/sandstorm start\nExecStop=$PWD/sandstorm stop\n\n[Install]\nWantedBy=multi-user.target\n__EOF__\n  systemctl enable sandstorm\n  systemctl start sandstorm\n  STARTED_SANDSTORM=\"yes\"\n}\n\nconfigure_sysvinit_init_system() {\n  # WARNING: This function should only be run if we already know\n  # sysvinit is the current init system. It relies on its caller to\n  # verify that.\n\n  # Stop Sandstorm, since we don't know what its configuration is.\n  if [ -e /etc/init.d/sandstorm ] ; then\n    service sandstorm stop || true\n  fi\n\n  # Replace the init script with something that should definitely\n  # work.\n\n  cat &gt; /etc/init.d/sandstorm &lt;&lt; __EOF__\n#! /bin/bash\n### BEGIN INIT INFO\n# Provides:          sandstorm\n# Required-Start:    \\$local_fs \\$remote_fs \\$networking \\$syslog\n# Required-Stop:     \\$local_fs \\$remote_fs \\$networking \\$syslog\n# Default-Start:     2 3 4 5\n# Default-Stop:      0 1 6\n# Short-Description: starts Sandstorm personal cloud server\n### END INIT INFO\n\nDESC=\"Sandstorm server\"\nDAEMON=$PWD/sandstorm\n\n# The Sandstorm runner supports all the common init commands directly.\n# We use -a to set the program name to make help text look nicer.\n# This requires bash, though.\nexec -a \"service sandstorm\" \\$DAEMON \"\\$@\"\n__EOF__\n\n  # Mark as executable, and enable on boot.\n  chmod +x /etc/init.d/sandstorm\n  if [ \"$(which update-rc.d)\" != \"\" ]; then\n    update-rc.d sandstorm defaults\n  elif [ \"$(which rc-update)\" != \"\" ]; then\n    rc-update add sandstorm\n  else\n    echo \"WARNING: I couldn't figure out how to make the Sandstorm init script active on\" &gt;&amp;2\n    echo \"  your system; neither update-rc.d nor rc-update commands seem to exist. Sandstorm\" &gt;&amp;2\n    echo \"  will not start automatically at boot until you mark its init script active.\" &gt;&amp;2\n  fi\n\n  # Start it right now.\n  service sandstorm start\n  STARTED_SANDSTORM=\"yes\"\n}\n\ngenerate_admin_token() {\n  # If dev accounts are enabled, the user does not need an admin token.\n  if [ \"yes\" = \"${ALLOW_DEV_ACCOUNTS}\" ] ; then\n    return\n  fi\n\n  # Allow the person running the install.sh script to pre-generate an admin token, specified as an\n  # environment variable, so that they can ignore the output text of install.sh.\n  if [ ! -z \"${ADMIN_TOKEN:-}\" ] ; then\n    local TMPFILENAME=\"$(mktemp ./var/sandstorm/adminTokenTmp.XXXXXXXXXX)\"\n    echo -n \"$ADMIN_TOKEN\" &gt; \"$TMPFILENAME\"\n    local FILENAME=\"./var/sandstorm/adminToken\"\n    mv \"$TMPFILENAME\" \"$FILENAME\"\n    chmod 0640 \"$FILENAME\"\n    chgrp \"$SERVER_USER\" \"$FILENAME\"\n    return\n  fi\n\n  ADMIN_TOKEN=$(./sandstorm admin-token --quiet)\n}\n\nprint_success() {\n  echo \"\"\n  if [ \"yes\" = \"$SANDSTORM_NEEDS_TO_BE_STARTED\" ] ; then\n    echo \"Installation complete. To start your server now, run:\"\n    echo \"  $DIR/sandstorm start\"\n    echo \"Once that's done, visit this link to start using it:\"\n  else\n    echo -n \"Your server is now online! \"\n    echo \"Visit this link to start using it:\"\n  fi\n\n  echo \"\"\n\n  # If there is an admin token at this point, print an admin token URL.  Otherwise, don't. Note that\n  # when dev accounts are enabled, it is advantageous to not print an admin token URL.\n  if [ ! -z \"${ADMIN_TOKEN:-}\" ] ; then\n    echo \"  ${BASE_URL:-(unknown; bad config)}/setup/token/$ADMIN_TOKEN\"\n    echo \"\"\n    echo \"NOTE: This URL expires in 15 minutes. You can generate a new setup URL by running\"\n    echo \"'sudo sandstorm admin-token' from the command line.\"\n  else\n    echo \"  ${BASE_URL:-(unknown; bad config)}/\"\n  fi\n  if [ \"yes\" = \"${ALLOW_DEV_ACCOUNTS}\" ] ; then\n   echo \"\"\n   echo \"NOTE: Use the passwordless admin account called Alice for convenient dev login (since you have 'dev \naccounts' enabled).\"\n  fi\n  echo \"\"\n\n  echo\n  echo \"To learn how to control the server, run:\"\n  if [ \"yes\" = \"$CURRENTLY_UID_ZERO\" ] ; then\n    echo \"  sandstorm help\"\n  else\n    echo \"  $DIR/sandstorm help\"\n  fi\n}\n\nsandcats_provide_help() {\n  echo \"Sandcats.io is a free dynamic DNS service run by the Sandstorm development team.\"\n  echo \"\"\n  echo \"You can:\"\n  echo \"\"\n  echo \"* Read more about it at:\"\n  echo \"  https://docs.sandstorm.io/en/latest/administering/sandcats/\"\n  echo \"\"\n  echo \"* Recover access to a domain you once registered with sandcats\"\n  echo \"\"\n  echo \"* Just press enter to go to the previous question.\"\n  sandcats_recover_domain\n}\n\nsandcats_recover_domain() {\n  DESIRED_SANDCATS_NAME=$(prompt \"What Sandcats subdomain do you want to recover?\" \"none\")\n\n  # If the user wants none of our help, then go back to registration.\n  if [ \"none\" = \"$DESIRED_SANDCATS_NAME\" ] ; then\n    unset DESIRED_SANDCATS_NAME\n    sandcats_register_name\n    return\n  fi\n\n  # If the user gave us a hostname that contains a dot, tell them they need to re-enter it.\n  if [[ $DESIRED_SANDCATS_NAME =~ [.] ]] ; then\n    echo \"\"\n    echo \"You entered: $DESIRED_SANDCATS_NAME\"\n    echo \"\"\n    echo \"but this function just wants the name of your subdomain, not including any dot characters.\"\n    echo \"Please try again.\"\n    echo \"\"\n    sandcats_recover_domain\n    return\n  fi\n\n  echo \"OK. We will send a recovery token to the email address on file. Type no to abort.\"\n  OK_TO_CONTINUE=$(prompt \"OK to continue?\" \"yes\")\n  if [ \"no\" = \"$OK_TO_CONTINUE\" ] ; then\n    unset DESIRED_SANDCATS_NAME\n    sandcats_register_name\n    return\n  fi\n\n  # First, we attempt to send the user a domain recovery token.\n  local LOG_PATH=\"var/sandcats/sendrecoverytoken-log\"\n  touch \"$LOG_PATH\"\n  chmod 0640 \"$LOG_PATH\"\n  HTTP_STATUS=$(\n    dotdotdot_curl \\\n      --silent \\\n      --max-time 20 \\\n      $SANDCATS_CURL_PARAMS \\\n      -A \"$CURL_USER_AGENT\" \\\n      -X POST \\\n      --data-urlencode \"rawHostname=$DESIRED_SANDCATS_NAME\" \\\n      --output \"$LOG_PATH\" \\\n      -w '%{http_code}' \\\n      -H 'X-Sand: cats' \\\n      -H \"Accept: text/plain\" \\\n      \"${SANDCATS_API_BASE}/sendrecoverytoken\")\n\n  if [ \"200\" != \"$HTTP_STATUS\" ] ; then\n    error \"$(cat $LOG_PATH)\"\n    sandcats_recover_domain\n    return\n  fi\n\n  # Show the server's output, which presumably is some happy\n  # message.\n  cat \"$LOG_PATH\"\n  # Make sure that is on a line of its own.\n  echo ''\n  TOKEN=$(prompt \"Please enter the token that we sent to you by email.\" '')\n\n  # If the token is empty, then they just hit enter; take them to the start of help.\n  if [ -z \"$TOKEN\" ] ; then\n    error \"Empty tokens are not valid.\"\n    sandcats_recover_domain\n    return\n  fi\n\n  # Let's submit that token to the server's \"recover\" endpoint.\n  #\n  # This action registers the new key as the authoritative key for\n  # this hostname. It also sends an email to the user telling them\n  # that we changed the key they have on file.\n  local LOG_PATH=\"var/sandcats/recover-log\"\n  touch \"$LOG_PATH\"\n  chmod 0640 \"$LOG_PATH\"\n  HTTP_STATUS=$(\n      dotdotdot_curl \\\n      --silent \\\n      --max-time 20 \\\n      $SANDCATS_CURL_PARAMS \\\n      -A \"$CURL_USER_AGENT\" \\\n      -X POST \\\n      --data-urlencode \"rawHostname=$DESIRED_SANDCATS_NAME\" \\\n      --data-urlencode \"recoveryToken=$TOKEN\" \\\n      --output \"$LOG_PATH\" \\\n      -w '%{http_code}' \\\n      -H 'X-Sand: cats' \\\n      -H \"Accept: text/plain\" \\\n      --cert var/sandcats/id_rsa.private_combined \\\n      \"${SANDCATS_API_BASE}/recover\")\n\n  if [ \"200\" != \"$HTTP_STATUS\" ] ; then\n    error \"$(cat $LOG_PATH)\"\n    sandcats_recover_domain\n    return\n  fi\n\n  # Show the server's output, which presumably is some happy\n  # message.\n  cat \"$LOG_PATH\"\n  # Make sure that is on a line of its own.\n  echo ''\n\n  # Now we can do a call to /update, which we will do silently on the\n  # user's behalf. This uses the new key we registered (via /recover)\n  # and sets the IP address for this host in the sandcats.io DNS\n  # service.\n  local LOG_PATH=\"var/sandcats/update-log\"\n  touch \"$LOG_PATH\"\n  chmod 0640 \"$LOG_PATH\"\n  HTTP_STATUS=$(\n    dotdotdot_curl \\\n      --silent \\\n      --max-time 20 \\\n      $SANDCATS_CURL_PARAMS \\\n      -A \"$CURL_USER_AGENT\" \\\n      -X POST \\\n      --data-urlencode \"rawHostname=$DESIRED_SANDCATS_NAME\" \\\n      --output \"$LOG_PATH\" \\\n      -w '%{http_code}' \\\n      -H 'X-Sand: cats' \\\n      -H \"Accept: text/plain\" \\\n      --cert var/sandcats/id_rsa.private_combined \\\n      \"${SANDCATS_API_BASE}/update\")\n\n  if [ \"200\" != \"$HTTP_STATUS\" ] ; then\n    error \"$(cat $LOG_PATH)\"\n    sandcats_recover_domain\n    return\n  fi\n\n  # Show the server's happy message.\n  cat \"$LOG_PATH\"\n  # Make sure that is on a line of its own.\n  echo ''\n\n  SANDCATS_SUCCESSFUL=\"yes\"\n  SS_HOSTNAME=\"${DESIRED_SANDCATS_NAME}.${SANDCATS_BASE_DOMAIN}\"\n  USE_EXTERNAL_INTERFACE=\"yes\"\n  USE_HTTPS=\"yes\"\n  echo \"Congratulations! You're all configured to use ${DESIRED_SANDCATS_NAME}.${SANDCATS_BASE_DOMAIN}.\"\n  echo \"Your credentials to use it are in $(readlink -f var/sandcats); consider making a backup.\"\n}\n\nsandcats_registerreserved() {\n  echo \"Registering your pre-reserved domain.\"\n  local LOG_PATH\n  LOG_PATH=\"var/sandcats/registerreserved-log\"\n  touch \"$LOG_PATH\"\n  chmod 0640 \"$LOG_PATH\"\n  HTTP_STATUS=$(\n    dotdotdot_curl \\\n      --silent \\\n      --max-time 20 \\\n      $SANDCATS_CURL_PARAMS \\\n      -A \"$CURL_USER_AGENT\" \\\n      -X POST \\\n      --data-urlencode \"domainReservationToken=$SANDCATS_DOMAIN_RESERVATION_TOKEN\" \\\n      --data-urlencode \"rawHostname=$DESIRED_SANDCATS_NAME\" \\\n      --output \"$LOG_PATH\" \\\n      -w '%{http_code}' \\\n      -H 'X-Sand: cats' \\\n      -H \"Accept: text/plain\" \\\n      --cert var/sandcats/id_rsa.private_combined \\\n      \"${SANDCATS_API_BASE}/registerreserved\")\n\n  if [ \"200\" = \"$HTTP_STATUS\" ]\n  then\n    # Show the server's output, which presumably is some happy\n    # message.\n    cat \"$LOG_PATH\"\n    # Make sure that is on a line of its own.\n    echo ''\n    # Set these global variables to inform the installer down the\n    # road.\n    SS_HOSTNAME=\"${DESIRED_SANDCATS_NAME}.${SANDCATS_BASE_DOMAIN}\"\n    USE_EXTERNAL_INTERFACE=\"yes\"\n    USE_HTTPS=\"yes\"\n    SANDCATS_SUCCESSFUL=\"yes\"\n    echo \"Congratulations! We have registered your ${DESIRED_SANDCATS_NAME}.${SANDCATS_BASE_DOMAIN} name.\"\n    echo \"Your credentials to use it are in $(readlink -f var/sandcats); consider making a backup.\"\n  else\n    # Show the server's output, and bail out.\n    #\n    # TODO(soon): Wait 1 minute in case the sandcats.io service had a brief hiccup, and retry (let's\n    # say) 5 times.\n    fail \"E_SANDCATS_REGISTER_RESERVED_SRV_FAIL\" \"$(cat \"$LOG_PATH\")\"\n  fi\n}\n\nsandcats_register_name() {\n  # We allow environment variables to override some details of the\n  # Sandcats service, so that during development, we can test against\n  # a non-production Sandcats service.\n  SANDCATS_API_BASE=\"${OVERRIDE_SANDCATS_API_BASE:-https://sandcats.io}\"\n  SANDCATS_CURL_PARAMS=\"${OVERRIDE_SANDCATS_CURL_PARAMS:-}\"\n\n  # If there is a SANDCATS_DOMAIN_RESERVATION_TOKEN provided, then we call a different function to\n  # do the work.\n  if [ ! -z \"${SANDCATS_DOMAIN_RESERVATION_TOKEN:-}\" ] ; then\n    sandcats_registerreserved\n    return\n  fi\n\n  if [ -z \"${DESIRED_SANDCATS_NAME:-}\" ] ; then\n    echo \"Choose your desired Sandcats subdomain (alphanumeric, max 20 characters).\"\n    echo \"Type the word none to skip this step, or help for help.\"\n    DESIRED_SANDCATS_NAME=$(prompt \"What *.${SANDCATS_BASE_DOMAIN} subdomain would you like?\" '')\n  fi\n\n  # If they just press enter, insist that they type either the word\n  # \"none\" or provide a name they want to register.\n  if [ -z \"$DESIRED_SANDCATS_NAME\" ] ; then\n    sandcats_register_name\n    return\n  fi\n\n  # If the user really wants none of our sandcats help, then bail out.\n  if [ \"none\" = \"$DESIRED_SANDCATS_NAME\" ] ; then\n    return\n  fi\n\n  # If the user wants help, offer help.\n  if [ \"help\" = \"$DESIRED_SANDCATS_NAME\" ] ; then\n    sandcats_provide_help\n    return\n  fi\n\n  # Validate the client-side, to avoid problems, against a slightly\n  # less rigorous regex than the server is using.\n  if ! [[ $DESIRED_SANDCATS_NAME =~ ^[0-9a-zA-Z-]{1,20}$ ]] ; then\n    unset DESIRED_SANDCATS_NAME\n    sandcats_register_name\n    return\n  fi\n\n  # Ask them for their email address, since we use that as part of Sandcats\n  # registration.\n  if [ -z \"${SANDCATS_REGISTRATION_EMAIL:-}\" ]; then\n    echo \"We need your email on file so we can help you recover your domain if you lose access. No spam.\"\n    SANDCATS_REGISTRATION_EMAIL=$(prompt \"Enter your email address:\" \"\")\n\n    # If the user fails to enter an email address, bail out.\n    while [ \"\" = \"$SANDCATS_REGISTRATION_EMAIL\" ] ; do\n      echo \"For the DNS service, we really do need an email address. To cancel, type: Ctrl-C.\"\n      SANDCATS_REGISTRATION_EMAIL=$(prompt \"Enter your email address:\" \"\")\n    done\n  fi\n\n  echo \"Registering your domain.\"\n  local LOG_PATH\n  LOG_PATH=\"var/sandcats/register-log\"\n  touch \"$LOG_PATH\"\n  chmod 0640 \"$LOG_PATH\"\n  HTTP_STATUS=$(\n    dotdotdot_curl \\\n      --silent \\\n      --max-time 20 \\\n      $SANDCATS_CURL_PARAMS \\\n      -A \"$CURL_USER_AGENT\" \\\n      -X POST \\\n      --data-urlencode \"rawHostname=$DESIRED_SANDCATS_NAME\" \\\n      --data-urlencode \"email=$SANDCATS_REGISTRATION_EMAIL\" \\\n      --output \"$LOG_PATH\" \\\n      -w '%{http_code}' \\\n      -H 'X-Sand: cats' \\\n      -H \"Accept: text/plain\" \\\n      --cert var/sandcats/id_rsa.private_combined \\\n      \"${SANDCATS_API_BASE}/register\")\n\n  if [ \"200\" = \"$HTTP_STATUS\" ]\n  then\n    # Show the server's output, which presumably is some happy\n    # message.\n    cat \"$LOG_PATH\"\n    # Make sure that is on a line of its own.\n    echo ''\n    # Set these global variables to inform the installer down the\n    # road.\n    SS_HOSTNAME=\"${DESIRED_SANDCATS_NAME}.${SANDCATS_BASE_DOMAIN}\"\n    USE_EXTERNAL_INTERFACE=\"yes\"\n    USE_HTTPS=\"yes\"\n    SANDCATS_SUCCESSFUL=\"yes\"\n    echo \"Congratulations! We have registered your ${DESIRED_SANDCATS_NAME}.${SANDCATS_BASE_DOMAIN} name.\"\n    echo \"Your credentials to use it are in $(readlink -f var/sandcats); consider making a backup.\"\n  else\n    # Show the server's output, and re-run this function.\n    error \"$(cat \"$LOG_PATH\")\"\n    unset DESIRED_SANDCATS_NAME\n    unset SANDCATS_REGISTRATION_EMAIL\n    sandcats_register_name\n    return\n  fi\n}\n\nwait_for_server_bind_to_its_port() {\n  # If we haven't started Sandstorm ourselves, it's not sensible to expect it to be listening.\n  if [ \"yes\" != \"${STARTED_SANDSTORM}\" ] ; then\n    return\n  fi\n\n  # For sandcats HTTPS, we have to generate the initial non-SNI key before Sandstorm binds to port\n  # 443. So we let the user know it could be slow. For all users, using the admin token requires\n  # that the server has started.\n  local PORT_TO_CHECK=\"${HTTPS_PORT:-$PORT}\"\n  echo -n \"Your server is coming online. Waiting up to 90 seconds...\"\n  local ONLINE_YET=\"no\"\n  for waited_n_seconds in $(seq 0 89); do\n    is_port_bound \"${BIND_IP}\" \"${PORT_TO_CHECK}\" &amp;&amp; ONLINE_YET=\"yes\"\n    if [ \"$ONLINE_YET\" == \"yes\" ] ; then\n      echo ''\n      break\n    fi\n    echo -n \".\"\n    sleep 1\n  done\n\n  # One last check before we bail out.\n  is_port_bound \"${BIND_IP}\" \"${PORT_TO_CHECK}\" &amp;&amp; ONLINE_YET=\"yes\"\n\n  if [ \"$ONLINE_YET\" == \"yes\" ]; then\n    return\n  else\n    fail \"E_NEVER_LISTENED\" \"Your server never started listening.\"\n  fi\n}\n\nsandcats_generate_keys() {\n    # The Sandcats service places its authentication files in $DIR/var/sandcats.\n    if [ -f var/sandcats/id_rsa.private_combined ] ; then\n        return\n    fi\n\n    # The openssl key generation process can take a few seconds, so we\n    # print a ... while that happens.\n    echo -n '...'\n\n    # We are already in $DIR. It's important to make it mode 0700\n    # because we store TLS client authentication keys here.\n    mkdir -p -m 0700 var/sandcats\n    chmod 0700 var/sandcats\n\n    # If we are root, we must chown the Sandcats configuration\n    # directory to the user that will be running Sandstorm.\n    if [ \"yes\" = \"$CURRENTLY_UID_ZERO\" ] ; then\n        chown \"$SERVER_USER\":\"$SERVER_USER\" var/sandcats\n    fi\n\n    # Generate key for client certificate. OpenSSL will read from\n    # /dev/urandom by default, so this won't block. We abuse the ``\n    # operator so we can have inline comments in a multi-line command.\n    openssl \\\n        req `# Invoke OpenSSL's PKCS#10 X.509 bits.` \\\n        -new `# Create a new certificate/request.` \\\n        -newkey rsa:4096 `# Create a new RSA key of length 4096 bits.` \\\n        -days 3650 `# Make the self-signed cert valid for 10 years.` \\\n        -nodes `# no DES -- that is, do not encrypt the key at rest.` \\\n        -x509 `# Output a certificate, rather than a signing request.` \\\n        `# Sandcats ignores the subject in the certificate; use` \\\n        `# OpenSSL defaults.` \\\n        -subj \"/C=AU/ST=Some-State/O=Internet Widgits Pty Ltd\" \\\n        -keyout var/sandcats/id_rsa `# Store the resulting RSA private key in id_rsa` \\\n        -out var/sandcats/id_rsa.pub `# Store the resulting certificate in id_rsa.pub` \\\n        2&gt;/dev/null `# Silence the progress output.`\n\n    # We combine these two things into one glorious all-inclusive file\n    # for the `curl` command. It is just as private as id_rsa.\n    cat var/sandcats/id_rsa var/sandcats/id_rsa.pub &gt; var/sandcats/id_rsa.private_combined\n\n    # Set filesystem permissions, in case the files get copied\n    # into the wrong place later.\n    chmod 0640 var/sandcats/id_rsa var/sandcats/id_rsa.pub var/sandcats/id_rsa.private_combined\n\n    # If we are root, make sure the files are owned by the\n    # $SERVER_USER. This way, Sandstorm can actually read them.\n    if [ \"yes\" = \"$CURRENTLY_UID_ZERO\" ] ; then\n        chown \"$SERVER_USER\":\"$SERVER_USER\" var/sandcats/id_rsa{,.pub,.private_combined}\n    fi\n\n    # Go to the start of the line, before the \"...\" that we\n    # left on the screen, allowing future echo statements to\n    # overwrite it.\n    echo -ne '\\r'\n}\n\nconfigure_https() {\n  if [ \"yes\" != \"${USE_HTTPS}\" ] ; then\n    return\n  fi\n\n  echo\n  echo \"Now we're going to fetch a TLS certificate using Let's Encrypt. This is a free\"\n  echo \"service provided by the nonprofit Electronic Frontier Foundation. By using this\"\n  echo \"service, you agree to be bound by the subscriber agreement, found here:\"\n  echo \"  https://letsencrypt.org/repository/#let-s-encrypt-subscriber-agreement\"\n  echo \"If you do not agree, please press ctrl+C now to cancel installation.\"\n  echo\n\n  if [ -z \"${ACME_EMAIL:-}\" ]; then\n    echo \"You must provide an email address, which will be shared with Let's Encrypt.\"\n    ACME_EMAIL=\"$(prompt \"Your email address for Let's Encrypt:\" \"${SANDCATS_REGISTRATION_EMAIL:-}\")\"\n  fi\n\n  $DIR/sandstorm create-acme-account \"$ACME_EMAIL\" --accept-terms ||\n      fail \"E_CREATE_ACME_ACCOUNT\" \"Failed to create Let's Encrypt account.\"\n\n  echo \"Your Let's Encrypt account has been created. Now we'll fetch a certificate!\"\n  $DIR/sandstorm renew-certificate ||\n      fail \"E_FETCH_CERTIFICATE\" \"Failed to fetch certificate.\"\n}\n\n# Now that the steps exist as functions, run them in an order that\n# would result in a working install.\nhandle_args \"$@\"\nset_umask\nassert_on_terminal\nassert_linux_x86_64\nassert_usable_kernel\ndetect_current_uid\nassert_dependencies\nassert_valid_bundle_file\ndetect_init_system\nchoose_install_mode\nmaybe_enable_userns_sysctl\nchoose_external_or_internal\nchoose_install_dir\nchoose_smtp_port\nload_existing_settings\nchoose_server_user_if_needed\ncreate_server_user_if_needed\nconfigure_auto_updates\nconfigure_dev_accounts\nconfigure_hostnames\nsave_config\ndownload_latest_bundle_and_extract_if_needed\nextract_bundle_if_provided\nmake_runtime_directories\ngenerate_admin_token\nset_permissions\ninstall_sandstorm_symlinks\nask_about_starting_at_boot\nconfigure_start_at_boot_if_desired\nwait_for_server_bind_to_its_port\nconfigure_https\nprint_success\n}\n\n# Now that we know the whole script has downloaded, run it.\n_ \"$0\" \"$@\"\n</code></pre>"},{"location":"examples/laravel.build.ce/","title":"laravel.build/example-app","text":""},{"location":"examples/laravel.build.ce/#description","title":"Description","text":"<ul> <li>run <code>curl -s https://laravel.build/example-app | bash</code> to create a new DOcker-based Laravel app</li> <li>cf https://laravel.com/docs/11.x </li> </ul>"},{"location":"examples/laravel.build.ce/#stats","title":"Stats","text":"<pre><code>-------------------------------------------------------------------------------\nLanguage                     files          blank        comment           code\n-------------------------------------------------------------------------------\nBourne Shell                     1              9              2             41\n-------------------------------------------------------------------------------\n</code></pre>"},{"location":"examples/laravel.build.ce/#code","title":"Code","text":"<pre><code>docker info &gt; /dev/null 2&gt;&amp;1\n\n# Ensure that Docker is running...\nif [ $? -ne 0 ]; then\n    echo \"Docker is not running.\"\n\n    exit 1\nfi\n\ndocker run --rm \\\n    --pull=always \\\n    -v \"$(pwd)\":/opt \\\n    -w /opt \\\n    laravelsail/php84-composer:latest \\\n    bash -c \"laravel new example-app --no-interaction &amp;&amp; cd example-app &amp;&amp; php ./artisan sail:install \n--with=mysql,redis,meilisearch,mailpit,selenium \"\n\ncd example-app\n\n# Allow build with no additional services..\nif [ \"mysql redis meilisearch mailpit selenium\" == \"none\" ]; then\n    ./vendor/bin/sail build\nelse\n    ./vendor/bin/sail pull mysql redis meilisearch mailpit selenium\n    ./vendor/bin/sail build\nfi\n\nCYAN='\\033[0;36m'\nLIGHT_CYAN='\\033[1;36m'\nBOLD='\\033[1m'\nNC='\\033[0m'\n\necho \"\"\n\nif command -v doas &amp;&gt;/dev/null; then\n    SUDO=\"doas\"\nelif command -v sudo &amp;&gt;/dev/null; then\n    SUDO=\"sudo\"\nelse\n    echo \"Neither sudo nor doas is available. Exiting.\"\n    exit 1\nfi\n\nif $SUDO -n true 2&gt;/dev/null; then\n    $SUDO chown -R $USER: .\n    echo -e \"${BOLD}Get started with:${NC} cd example-app &amp;&amp; ./vendor/bin/sail up\"\nelse\n    echo -e \"${BOLD}Please provide your password so we can make some final adjustments to your application's \npermissions.${NC}\"\n    echo \"\"\n    $SUDO chown -R $USER: .\n    echo \"\"\n    echo -e \"${BOLD}Thank you! We hope you build something incredible. Dive in with:${NC} cd example-app &amp;&amp; \n./vendor/bin/sail up\"\nfi\n</code></pre>"},{"location":"examples/php.new.d9/","title":"php.new/install/mac/8.4","text":""},{"location":"examples/php.new.d9/#description","title":"Description","text":"<ul> <li>run <code>curl -s https://php.new/install/mac/8.4 | bash</code> to install PHP, Composer and Laravel</li> <li>cf https://php.new/ </li> </ul>"},{"location":"examples/php.new.d9/#stats","title":"Stats","text":"<pre><code>-------------------------------------------------------------------------------\nLanguage                     files          blank        comment           code\n-------------------------------------------------------------------------------\nBourne Shell                     1             53             22            165\n-------------------------------------------------------------------------------\n</code></pre>"},{"location":"examples/php.new.d9/#code","title":"Code","text":"<p>```bash</p>"},{"location":"examples/php.new.d9/#binbash","title":"!/bin/bash","text":"<p>set -euo pipefail</p>"},{"location":"examples/php.new.d9/#define-variables","title":"Define variables","text":"<p>BASE_URL=\"https://download.herdphp.com\" INSTALL_DIR=\"$HOME/.config/herd-lite/bin\" PHP_BIN=\"$INSTALL_DIR/php\" COMPOSER_BIN=\"$INSTALL_DIR/composer\" LARAVEL_BIN=\"$INSTALL_DIR/laravel\"</p> <p>if [ ! -t 1 ]; then   NO_TTY=true else   NO_TTY=false fi</p>"},{"location":"examples/php.new.d9/#create-the-directory-if-it-doesnt-exist","title":"Create the directory if it doesn't exist","text":"<p>mkdir -p \"$INSTALL_DIR\"</p>"},{"location":"examples/php.new.d9/#helper-functions","title":"Helper functions","text":"<p>show_spinner() {   if [ \"$NO_TTY\" = true ]; then     return   fi</p> <p>local pid=$1   local delay=0.1   local spinstr='|/-\\'   local i=0</p> <p>while [ \"$(ps a | awk '{print $1}' | grep $pid)\" ]; do     # Get the current character for the spinner     printf \"\\b%c\" \"${spinstr:i++%${#spinstr}:1}\"     sleep $delay   done</p> <p># Clear the spinner once the process is complete   printf \"\\b \\b \\n\" }</p> <p>download_with_spinner() {   local url=$1   local output_file=$2</p> <p># Start curl in the background, suppressing all output and errors   curl -L \"$url\" -o \"$output_file\" &gt; /dev/null 2&gt;&amp;1 &amp;</p> <p># Capture the PID of curl   local curl_pid=$!</p> <p># Show the spinner while curl is running   show_spinner $curl_pid</p> <p># Wait for curl to complete   wait $curl_pid</p> <p># Check if the download was successful   if [ $? -eq 0 ]; then     #success \"File downloaded successfully to $output_file.\"     chmod +x \"$output_file\"   else     error \"Failed to download file from $url.\"     exit 1   fi }</p> <p>info() {     local blue_bg=\"\\033[44m\"     local white_text=\"\\033[97m\"     local reset=\"\\033[0m\"     printf \" ${blue_bg}${white_text} INFO ${reset} $1\" }</p> <p>success() {     local green_bg=\"\\033[42m\"     local black_text=\"\\033[30m\"     local reset=\"\\033[0m\"     printf \" ${green_bg}${black_text} SUCCESS ${reset} $1 \\n\" }</p> <p>error() {     local red_bg=\"\\033[41m\"     local white_text=\"\\033[97m\"     local reset=\"\\033[0m\"     printf \" ${red_bg}${white_text} ERROR ${reset} $1 \\n\" }</p> <p>if [ \"$NO_TTY\" = false ]; then   clear fi</p> <p>HERD_IS_INSTALLED=false if [ -f \"$HOME/Library/Application Support/Herd/bin/php\" ]; then   HERD_IS_INSTALLED=true fi</p> <p>if [ \"$HERD_IS_INSTALLED\" = true ]; then     info \"You already use Laravel Herd - are you sure you want to install another copy of PHP? (y/n) \"     read -r CONTINUE_INSTALL</p> <pre><code>if [ \"$CONTINUE_INSTALL\" != \"y\" ]; then\n    exit 0\nfi\n</code></pre> <p>fi</p> <p>info \"Downloading PHP binary\u2026  \"</p> <p>if [ \"$(uname -m)\" == \"arm64\" ]; then     download_with_spinner \"$BASE_URL/herd-lite/macos/arm64/8.4/php\" \"$PHP_BIN\" else     download_with_spinner \"$BASE_URL/herd-lite/macos/x64/8.4/php\" \"$PHP_BIN\" fi</p> <p>info \"Downloading Composer binary\u2026  \" download_with_spinner \"$BASE_URL/herd-lite/composer\" \"$COMPOSER_BIN\"</p> <p>info \"Downloading Laravel installer  \" download_with_spinner \"$BASE_URL/herd-lite/laravel\" \"$LARAVEL_BIN\"</p> <p>info \"Downloading cacert.pem\u2026  \" download_with_spinner \"https://curl.se/ca/cacert.pem\" \"$INSTALL_DIR/cacert.pem\"</p> <p>if [ ! -f \"$INSTALL_DIR/php.ini\" ]; then   touch \"$INSTALL_DIR/php.ini\"</p> <p>echo \"curl.cainfo=$INSTALL_DIR/cacert.pem\" &gt;&gt; \"$INSTALL_DIR/php.ini\"   echo \"openssl.cafile=$INSTALL_DIR/cacert.pem\" &gt;&gt; \"$INSTALL_DIR/php.ini\"   echo \"pcre.jit=0\" &gt;&gt; \"$INSTALL_DIR/php.ini\" fi</p>"},{"location":"examples/php.new.d9/#detect-the-current-shell","title":"Detect the current shell","text":"<p>CURRENT_SHELL=$(basename \"$SHELL\")</p>"},{"location":"examples/php.new.d9/#determine-profile-files-to-update","title":"Determine profile files to update","text":"<p>PROFILE_FILES=()</p> <p>case \"$CURRENT_SHELL\" in   bash)     PROFILE_FILES=(\"$HOME/.bashrc\" \"$HOME/.bash_profile\" \"$HOME/.profile\")     ;;   zsh)     PROFILE_FILES=(\"$HOME/.zshrc\" \"$HOME/.zprofile\" \"$HOME/.profile\")     ;;   *)     PROFILE_FILES=(\"$HOME/.profile\")     error \"Unknown shell. Defaulting to update ~/.profile.\"     ;; esac</p>"},{"location":"examples/php.new.d9/#add-the-installation-directory-to-the-path-if-not-already-present","title":"Add the installation directory to the PATH if not already present","text":"<p>PATH_UPDATED=false if [[ \":$PATH:\" != \":$INSTALL_DIR:\" ]]; then   info \"Adding $INSTALL_DIR to your PATH... \\n\"   for PROFILE_FILE in \"${PROFILE_FILES[@]}\"; do     if [[ -f \"$PROFILE_FILE\" ]]; then       if ! grep -q \"$INSTALL_DIR\" \"$PROFILE_FILE\"; then         echo \"export PATH=\\\"$INSTALL_DIR:\\$PATH\\\"\" &gt;&gt; \"$PROFILE_FILE\"         echo \"export PHP_INI_SCAN_DIR=\\\"$INSTALL_DIR:\\$PHP_INI_SCAN_DIR\\\"\" &gt;&gt; \"$PROFILE_FILE\"         info \"Added $INSTALL_DIR to PATH in $PROFILE_FILE \\n\"         PATH_UPDATED=true         break       fi     fi   done</p> <p>if [ \"$PATH_UPDATED\" = false ]; then     error \"Could not automatically update your PATH. Please add the following line to your shell profile:\"     error \"export PATH=\\\"$INSTALL_DIR:\\$PATH\\\"\"   fi else   info \"$INSTALL_DIR is already in your PATH. \\n\" fi</p>"},{"location":"examples/php.new.d9/#create-uninstall-script-if-it-doesnt-exist","title":"Create uninstall script if it doesn't exist","text":"<p>if [ ! -f \"$INSTALL_DIR/uninstall_herd_lite\" ]; then   cat &gt; \"$INSTALL_DIR/uninstall_herd_lite\" &lt;&lt;EOF</p>"},{"location":"examples/php.new.d9/#binbash_1","title":"!/bin/bash","text":"<p>INSTALL_DIR=\"$INSTALL_DIR\"</p>"},{"location":"examples/php.new.d9/#remove-the-installation-directory","title":"Remove the installation directory","text":"<p>rm -rf \"\\$INSTALL_DIR\"</p> <p>echo \"PHP has been uninstalled.\" EOF</p> <p>chmod +x \"$INSTALL_DIR/uninstall_herd_lite\" fi</p> <p>PHP_VERSION=$(\"$PHP_BIN\" -v | head -n 1 | cut -d ' ' -f 2)</p> <p>box() {   local msg=\"$1\"   local content=\"$2\"   local content2=\"$3\"   local content3=\"$4\"   local width=70  # Total width of the box</p> <p># Define ANSI color codes for light gray and reset   local light_gray=\"\\033[90m\"   local reset=\"\\033[0m\"</p> <p># Calculate lengths for padding and filling   local msg_length=${#msg}   local filler=$(($width - $msg_length - 5))</p> <p>local content_length=${#content}   local content_filler=$(($width - 4 - $content_length + 10))</p> <p>local content2_length=${#content2}   local content2_filler=$(($width - 4 - $content2_length + 8))</p> <p>local footer_width=$(($width - 3))</p> <p>if [ \"$PATH_UPDATED\" = true ]; then     local profile_content=\"Please restart your terminal or run \\e[1m'source $PROFILE_FILE'\\e[0m to update  your PATH.\"   fi</p> <p># Top of the box with the message, using light gray color   printf \"${light_gray}\u250c ${reset}\\033[42m\\e[1m\\033[30m${msg}\\e[0m${reset} ${light_gray}$(printf '\u2500%.0s'  $(seq 1 $filler))${reset}\\n\"</p> <p>printf \"${light_gray}\u2502 ${reset}${content}${reset}\\n\"   if [ \"$PATH_UPDATED\" = true ]; then     printf \"${light_gray}\u2502 ${reset}${profile_content}${reset}\\n\"   fi   printf \"${light_gray}\u2502 ${reset}\\n\"   printf \"${light_gray}\u2502 ${reset}${content2}${reset}\\n\"   printf \"${light_gray}\u2502 ${reset}${content3}${reset}\\n\"</p> <p># Bottom of the box, in light gray   printf \"${light_gray}\u2514$(printf '\u2500%.0s' $(seq 1 $footer_width))${reset}\\n\" }</p>"},{"location":"examples/php.new.d9/#example-usage","title":"Example usage","text":"<p>printf \"\\n\"</p> <p>box \"Success!\" \"\\e[1mphp\\e[0m, \\e[1mcomposer\\e[0m, and \\e[1mlaravel\\e[0m have been installed successfully.\"  \"For a \\e[1mfully-featured dev environment\\e[0m for PHP, check out\" \"Laravel Herd.  \\e[4m\\e[34mhttps://herd.laravel.com\"```</p>"},{"location":"examples/raw.githubusercontent.com.0c/","title":"/basherpm/basher/master/install.sh","text":""},{"location":"examples/raw.githubusercontent.com.0c/#description","title":"Description","text":"<ul> <li>run <code>curl -s https://raw.githubusercontent.com/basherpm/basher/master/install.sh | bash</code> to install basher, bash package manager</li> <li>cf https://www.basher.it/ </li> </ul>"},{"location":"examples/raw.githubusercontent.com.0c/#stats","title":"Stats","text":"<pre><code>-------------------------------------------------------------------------------\nLanguage                     files          blank        comment           code\n-------------------------------------------------------------------------------\nBourne Shell                     1             10             10             41\n-------------------------------------------------------------------------------\n</code></pre>"},{"location":"examples/raw.githubusercontent.com.0c/#code","title":"Code","text":"<pre><code>#!/usr/bin/env bash\n\ndie() {\n  echo \"!! $1 \" &gt;&amp;2\n  echo \"!! -----------------------------\" &gt;&amp;2\n  exit 1\n}\n\nxdg_basher_dir=\"${XDG_DATA_HOME:-$HOME/.local/share}/basher\"\n\n## stop if basher is already installed\n[[ -d \"$HOME/.basher\" ]] &amp;&amp; die \"basher is already installed on [$HOME/.basher]\"\n[[ -d \"$xdg_basher_dir\" ]] &amp;&amp; die \"basher is already installed on [$xdg_basher_dir]\"\n\n## stop if git is not installed\ngit version &gt;/dev/null 2&gt;&amp;1 || die \"git is not installed on this machine\"\n\n## install the scripts on ~/.basher\necho \". download basher code to ~/.basher\"\ngit clone https://github.com/basherpm/basher.git ~/.basher 2&gt; /dev/null\n\n## now check what shell is running\nshell_type=$(basename \"$SHELL\")\necho \". detected shell type: $shell_type\"\ncase \"$shell_type\" in\nbash)  startup_type=\"simple\" ; startup_script=\"$HOME/.bashrc\" ;;\nzsh)   startup_type=\"simple\" ; startup_script=\"$HOME/.zshrc\"  ;;\nsh)    startup_type=\"simple\" ; startup_script=\"$HOME/.profile\";;\nfish)  startup_type=\"fish\"   ; startup_script=\"$HOME/.config/fish/config.fish\"  ;;\n*)     startup_type=\"?\"      ; startup_script=\"\" ;   ;;\nesac\n\n## startup script should exist already\n[[ -n \"$startup_script\" &amp;&amp; ! -f \"$startup_script\" ]] &amp;&amp; die \"startup script [$startup_script] does not exist\"\n\n## basher_keyword will allow us to remove the lines upon uninstall\nbasher_keyword=\"basher5ea843\"\n\n## now add the basher initialisation lines to the user's startup script\necho \". add basher initialisation to [$startup_script]\"\nif [[ \"$startup_type\" == \"simple\" ]]; then\n  (\n    echo \"export PATH=\\\"\\$HOME/.basher/bin:\\$PATH\\\"   ##$basher_keyword\"\n    # shellcheck disable=SC2086\n    echo \"eval \\\"\\$(basher init - $shell_type)\\\"             ##$basher_keyword\"\n  ) &gt;&gt;\"$startup_script\"\nelif [[ \"$startup_type\" == \"fish\" ]]; then\n  (\n    echo \"if test -d ~/.basher          ##$basher_keyword\"\n    echo \"  set basher ~/.basher/bin    ##$basher_keyword\"\n    echo \"end                           ##$basher_keyword\"\n    # shellcheck disable=SC2154\n    echo \"set -gx PATH \\$basher \\$PATH    ##$basher_keyword\"\n    echo \"status --is-interactive; and . (basher init - $shell_type | psub)    ##$basher_keyword\"\n  ) &gt;&gt;\"$startup_script\"\nelse\n  die \"unknown shell [$shell_type] - can't initialise\"\nfi\n\n## script is finished\necho \"basher is installed - open a new terminal window to start using it\"\n</code></pre>"},{"location":"examples/raw.githubusercontent.com.a3/","title":"/Homebrew/install/HEAD/install.sh","text":""},{"location":"examples/raw.githubusercontent.com.a3/#description","title":"Description","text":"<ul> <li>run <code>curl -s https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh | bash</code> to install homebrew, MacOS package manager</li> <li>cf https://brew.sh/ </li> </ul>"},{"location":"examples/raw.githubusercontent.com.a3/#stats","title":"Stats","text":"<pre><code>-------------------------------------------------------------------------------\nLanguage                     files          blank        comment           code\n-------------------------------------------------------------------------------\nBourne Shell                     1            127             58            933\n-------------------------------------------------------------------------------\n</code></pre>"},{"location":"examples/raw.githubusercontent.com.a3/#code","title":"Code","text":"<pre><code>#!/bin/bash\n\n# We don't need return codes for \"$(command)\", only stdout is needed.\n# Allow `[[ -n \"$(command)\" ]]`, `func \"$(command)\"`, pipes, etc.\n# shellcheck disable=SC2312\n\nset -u\n\nabort() {\n  printf \"%s\\n\" \"$@\" &gt;&amp;2\n  exit 1\n}\n\n# Fail fast with a concise message when not using bash\n# Single brackets are needed here for POSIX compatibility\n# shellcheck disable=SC2292\nif [ -z \"${BASH_VERSION:-}\" ]\nthen\n  abort \"Bash is required to interpret this script.\"\nfi\n\n# Check if script is run with force-interactive mode in CI\nif [[ -n \"${CI-}\" &amp;&amp; -n \"${INTERACTIVE-}\" ]]\nthen\n  abort \"Cannot run force-interactive mode in CI.\"\nfi\n\n# Check if both `INTERACTIVE` and `NONINTERACTIVE` are set\n# Always use single-quoted strings with `exp` expressions\n# shellcheck disable=SC2016\nif [[ -n \"${INTERACTIVE-}\" &amp;&amp; -n \"${NONINTERACTIVE-}\" ]]\nthen\n  abort 'Both `$INTERACTIVE` and `$NONINTERACTIVE` are set. Please unset at least one variable and try again.'\nfi\n\n# Check if script is run in POSIX mode\nif [[ -n \"${POSIXLY_CORRECT+1}\" ]]\nthen\n  abort 'Bash must not run in POSIX mode. Please unset POSIXLY_CORRECT and try again.'\nfi\n\n# string formatters\nif [[ -t 1 ]]\nthen\n  tty_escape() { printf \"\\033[%sm\" \"$1\"; }\nelse\n  tty_escape() { :; }\nfi\ntty_mkbold() { tty_escape \"1;$1\"; }\ntty_underline=\"$(tty_escape \"4;39\")\"\ntty_blue=\"$(tty_mkbold 34)\"\ntty_red=\"$(tty_mkbold 31)\"\ntty_bold=\"$(tty_mkbold 39)\"\ntty_reset=\"$(tty_escape 0)\"\n\nshell_join() {\n  local arg\n  printf \"%s\" \"$1\"\n  shift\n  for arg in \"$@\"\n  do\n    printf \" \"\n    printf \"%s\" \"${arg// /\\ }\"\n  done\n}\n\nchomp() {\n  printf \"%s\" \"${1/\"$'\\n'\"/}\"\n}\n\nohai() {\n  printf \"${tty_blue}==&gt;${tty_bold} %s${tty_reset}\\n\" \"$(shell_join \"$@\")\"\n}\n\nwarn() {\n  printf \"${tty_red}Warning${tty_reset}: %s\\n\" \"$(chomp \"$1\")\" &gt;&amp;2\n}\n\nusage() {\n  cat &lt;&lt;EOS\nHomebrew Installer\nUsage: [NONINTERACTIVE=1] [CI=1] install.sh [options]\n    -h, --help       Display this message.\n    NONINTERACTIVE   Install without prompting for user input\n    CI               Install in CI mode (e.g. do not prompt for user input)\nEOS\n  exit \"${1:-0}\"\n}\n\nwhile [[ $# -gt 0 ]]\ndo\n  case \"$1\" in\n    -h | --help) usage ;;\n    *)\n      warn \"Unrecognized option: '$1'\"\n      usage 1\n      ;;\n  esac\ndone\n\n# Check if script is run non-interactively (e.g. CI)\n# If it is run non-interactively we should not prompt for passwords.\n# Always use single-quoted strings with `exp` expressions\n# shellcheck disable=SC2016\nif [[ -z \"${NONINTERACTIVE-}\" ]]\nthen\n  if [[ -n \"${CI-}\" ]]\n  then\n    warn 'Running in non-interactive mode because `$CI` is set.'\n    NONINTERACTIVE=1\n  elif [[ ! -t 0 ]]\n  then\n    if [[ -z \"${INTERACTIVE-}\" ]]\n    then\n      warn 'Running in non-interactive mode because `stdin` is not a TTY.'\n      NONINTERACTIVE=1\n    else\n      warn 'Running in interactive mode despite `stdin` not being a TTY because `$INTERACTIVE` is set.'\n    fi\n  fi\nelse\n  ohai 'Running in non-interactive mode because `$NONINTERACTIVE` is set.'\nfi\n\n# USER isn't always set so provide a fall back for the installer and subprocesses.\nif [[ -z \"${USER-}\" ]]\nthen\n  USER=\"$(chomp \"$(id -un)\")\"\n  export USER\nfi\n\n# First check OS.\nOS=\"$(uname)\"\nif [[ \"${OS}\" == \"Linux\" ]]\nthen\n  HOMEBREW_ON_LINUX=1\nelif [[ \"${OS}\" == \"Darwin\" ]]\nthen\n  HOMEBREW_ON_MACOS=1\nelse\n  abort \"Homebrew is only supported on macOS and Linux.\"\nfi\n\n# Required installation paths. To install elsewhere (which is unsupported)\n# you can untar https://github.com/Homebrew/brew/tarball/master\n# anywhere you like.\nif [[ -n \"${HOMEBREW_ON_MACOS-}\" ]]\nthen\n  UNAME_MACHINE=\"$(/usr/bin/uname -m)\"\n\n  if [[ \"${UNAME_MACHINE}\" == \"arm64\" ]]\n  then\n    # On ARM macOS, this script installs to /opt/homebrew only\n    HOMEBREW_PREFIX=\"/opt/homebrew\"\n    HOMEBREW_REPOSITORY=\"${HOMEBREW_PREFIX}\"\n  else\n    # On Intel macOS, this script installs to /usr/local only\n    HOMEBREW_PREFIX=\"/usr/local\"\n    HOMEBREW_REPOSITORY=\"${HOMEBREW_PREFIX}/Homebrew\"\n  fi\n  HOMEBREW_CACHE=\"${HOME}/Library/Caches/Homebrew\"\n\n  STAT_PRINTF=(\"/usr/bin/stat\" \"-f\")\n  PERMISSION_FORMAT=\"%A\"\n  CHOWN=(\"/usr/sbin/chown\")\n  CHGRP=(\"/usr/bin/chgrp\")\n  GROUP=\"admin\"\n  TOUCH=(\"/usr/bin/touch\")\n  INSTALL=(\"/usr/bin/install\" -d -o \"root\" -g \"wheel\" -m \"0755\")\nelse\n  UNAME_MACHINE=\"$(uname -m)\"\n\n  # On Linux, this script installs to /home/linuxbrew/.linuxbrew only\n  HOMEBREW_PREFIX=\"/home/linuxbrew/.linuxbrew\"\n  HOMEBREW_REPOSITORY=\"${HOMEBREW_PREFIX}/Homebrew\"\n  HOMEBREW_CACHE=\"${HOME}/.cache/Homebrew\"\n\n  STAT_PRINTF=(\"/usr/bin/stat\" \"--printf\")\n  PERMISSION_FORMAT=\"%a\"\n  CHOWN=(\"/bin/chown\")\n  CHGRP=(\"/bin/chgrp\")\n  GROUP=\"$(id -gn)\"\n  TOUCH=(\"/bin/touch\")\n  INSTALL=(\"/usr/bin/install\" -d -o \"${USER}\" -g \"${GROUP}\" -m \"0755\")\nfi\nCHMOD=(\"/bin/chmod\")\nMKDIR=(\"/bin/mkdir\" \"-p\")\nHOMEBREW_BREW_DEFAULT_GIT_REMOTE=\"https://github.com/Homebrew/brew\"\nHOMEBREW_CORE_DEFAULT_GIT_REMOTE=\"https://github.com/Homebrew/homebrew-core\"\n\n# Use remote URLs of Homebrew repositories from environment if set.\nHOMEBREW_BREW_GIT_REMOTE=\"${HOMEBREW_BREW_GIT_REMOTE:-\"${HOMEBREW_BREW_DEFAULT_GIT_REMOTE}\"}\"\nHOMEBREW_CORE_GIT_REMOTE=\"${HOMEBREW_CORE_GIT_REMOTE:-\"${HOMEBREW_CORE_DEFAULT_GIT_REMOTE}\"}\"\n# The URLs with and without the '.git' suffix are the same Git remote. Do not prompt.\nif [[ \"${HOMEBREW_BREW_GIT_REMOTE}\" == \"${HOMEBREW_BREW_DEFAULT_GIT_REMOTE}.git\" ]]\nthen\n  HOMEBREW_BREW_GIT_REMOTE=\"${HOMEBREW_BREW_DEFAULT_GIT_REMOTE}\"\nfi\nif [[ \"${HOMEBREW_CORE_GIT_REMOTE}\" == \"${HOMEBREW_CORE_DEFAULT_GIT_REMOTE}.git\" ]]\nthen\n  HOMEBREW_CORE_GIT_REMOTE=\"${HOMEBREW_CORE_DEFAULT_GIT_REMOTE}\"\nfi\nexport HOMEBREW_{BREW,CORE}_GIT_REMOTE\n\n# TODO: bump version when new macOS is released or announced\nMACOS_NEWEST_UNSUPPORTED=\"16.0\"\n# TODO: bump version when new macOS is released\nMACOS_OLDEST_SUPPORTED=\"13.0\"\n\n# For Homebrew on Linux\nREQUIRED_RUBY_VERSION=2.6    # https://github.com/Homebrew/brew/pull/6556\nREQUIRED_GLIBC_VERSION=2.13  # https://docs.brew.sh/Homebrew-on-Linux#requirements\nREQUIRED_CURL_VERSION=7.41.0 # HOMEBREW_MINIMUM_CURL_VERSION in brew.sh in Homebrew/brew\nREQUIRED_GIT_VERSION=2.7.0   # HOMEBREW_MINIMUM_GIT_VERSION in brew.sh in Homebrew/brew\n\n# no analytics during installation\nexport HOMEBREW_NO_ANALYTICS_THIS_RUN=1\nexport HOMEBREW_NO_ANALYTICS_MESSAGE_OUTPUT=1\n\nunset HAVE_SUDO_ACCESS # unset this from the environment\n\nhave_sudo_access() {\n  if [[ ! -x \"/usr/bin/sudo\" ]]\n  then\n    return 1\n  fi\n\n  local -a SUDO=(\"/usr/bin/sudo\")\n  if [[ -n \"${SUDO_ASKPASS-}\" ]]\n  then\n    SUDO+=(\"-A\")\n  elif [[ -n \"${NONINTERACTIVE-}\" ]]\n  then\n    SUDO+=(\"-n\")\n  fi\n\n  if [[ -z \"${HAVE_SUDO_ACCESS-}\" ]]\n  then\n    if [[ -n \"${NONINTERACTIVE-}\" ]]\n    then\n      \"${SUDO[@]}\" -l mkdir &amp;&gt;/dev/null\n    else\n      \"${SUDO[@]}\" -v &amp;&amp; \"${SUDO[@]}\" -l mkdir &amp;&gt;/dev/null\n    fi\n    HAVE_SUDO_ACCESS=\"$?\"\n  fi\n\n  if [[ -n \"${HOMEBREW_ON_MACOS-}\" ]] &amp;&amp; [[ \"${HAVE_SUDO_ACCESS}\" -ne 0 ]]\n  then\n    abort \"Need sudo access on macOS (e.g. the user ${USER} needs to be an Administrator)!\"\n  fi\n\n  return \"${HAVE_SUDO_ACCESS}\"\n}\n\nexecute() {\n  if ! \"$@\"\n  then\n    abort \"$(printf \"Failed during: %s\" \"$(shell_join \"$@\")\")\"\n  fi\n}\n\nexecute_sudo() {\n  local -a args=(\"$@\")\n  if [[ \"${EUID:-${UID}}\" != \"0\" ]] &amp;&amp; have_sudo_access\n  then\n    if [[ -n \"${SUDO_ASKPASS-}\" ]]\n    then\n      args=(\"-A\" \"${args[@]}\")\n    fi\n    ohai \"/usr/bin/sudo\" \"${args[@]}\"\n    execute \"/usr/bin/sudo\" \"${args[@]}\"\n  else\n    ohai \"${args[@]}\"\n    execute \"${args[@]}\"\n  fi\n}\n\ngetc() {\n  local save_state\n  save_state=\"$(/bin/stty -g)\"\n  /bin/stty raw -echo\n  IFS='' read -r -n 1 -d '' \"$@\"\n  /bin/stty \"${save_state}\"\n}\n\nring_bell() {\n  # Use the shell's audible bell.\n  if [[ -t 1 ]]\n  then\n    printf \"\\a\"\n  fi\n}\n\nwait_for_user() {\n  local c\n  echo\n  echo \"Press ${tty_bold}RETURN${tty_reset}/${tty_bold}ENTER${tty_reset} to continue or any other key to \nabort:\"\n  getc c\n  # we test for \\r and \\n because some stuff does \\r instead\n  if ! [[ \"${c}\" == $'\\r' || \"${c}\" == $'\\n' ]]\n  then\n    exit 1\n  fi\n}\n\nmajor_minor() {\n  echo \"${1%%.*}.$(\n    x=\"${1#*.}\"\n    echo \"${x%%.*}\"\n  )\"\n}\n\nversion_gt() {\n  [[ \"${1%.*}\" -gt \"${2%.*}\" ]] || [[ \"${1%.*}\" -eq \"${2%.*}\" &amp;&amp; \"${1#*.}\" -gt \"${2#*.}\" ]]\n}\nversion_ge() {\n  [[ \"${1%.*}\" -gt \"${2%.*}\" ]] || [[ \"${1%.*}\" -eq \"${2%.*}\" &amp;&amp; \"${1#*.}\" -ge \"${2#*.}\" ]]\n}\nversion_lt() {\n  [[ \"${1%.*}\" -lt \"${2%.*}\" ]] || [[ \"${1%.*}\" -eq \"${2%.*}\" &amp;&amp; \"${1#*.}\" -lt \"${2#*.}\" ]]\n}\n\ncheck_run_command_as_root() {\n  [[ \"${EUID:-${UID}}\" == \"0\" ]] || return\n\n  # Allow Azure Pipelines/GitHub Actions/Docker/Concourse/Kubernetes to do everything as root (as it's normal \nthere)\n  [[ -f /.dockerenv ]] &amp;&amp; return\n  [[ -f /run/.containerenv ]] &amp;&amp; return\n  [[ -f /proc/1/cgroup ]] &amp;&amp; grep -E \"azpl_job|actions_job|docker|garden|kubepods\" -q /proc/1/cgroup &amp;&amp; return\n\n  abort \"Don't run this as root!\"\n}\n\nshould_install_command_line_tools() {\n  if [[ -n \"${HOMEBREW_ON_LINUX-}\" ]]\n  then\n    return 1\n  fi\n\n  if version_gt \"${macos_version}\" \"10.13\"\n  then\n    ! [[ -e \"/Library/Developer/CommandLineTools/usr/bin/git\" ]]\n  else\n    ! [[ -e \"/Library/Developer/CommandLineTools/usr/bin/git\" ]] ||\n      ! [[ -e \"/usr/include/iconv.h\" ]]\n  fi\n}\n\nget_permission() {\n  \"${STAT_PRINTF[@]}\" \"${PERMISSION_FORMAT}\" \"$1\"\n}\n\nuser_only_chmod() {\n  [[ -d \"$1\" ]] &amp;&amp; [[ \"$(get_permission \"$1\")\" != 75[0145] ]]\n}\n\nexists_but_not_writable() {\n  [[ -e \"$1\" ]] &amp;&amp; ! [[ -r \"$1\" &amp;&amp; -w \"$1\" &amp;&amp; -x \"$1\" ]]\n}\n\nget_owner() {\n  \"${STAT_PRINTF[@]}\" \"%u\" \"$1\"\n}\n\nfile_not_owned() {\n  [[ \"$(get_owner \"$1\")\" != \"$(id -u)\" ]]\n}\n\nget_group() {\n  \"${STAT_PRINTF[@]}\" \"%g\" \"$1\"\n}\n\nfile_not_grpowned() {\n  [[ \" $(id -G \"${USER}\") \" != *\" $(get_group \"$1\") \"* ]]\n}\n\n# Please sync with 'test_ruby()' in 'Library/Homebrew/utils/ruby.sh' from the Homebrew/brew repository.\ntest_ruby() {\n  if [[ ! -x \"$1\" ]]\n  then\n    return 1\n  fi\n\n  \"$1\" --enable-frozen-string-literal --disable=gems,did_you_mean,rubyopt -rrubygems -e \\\n    \"abort if Gem::Version.new(RUBY_VERSION.to_s.dup).to_s.split('.').first(2) != \\\n              Gem::Version.new('${REQUIRED_RUBY_VERSION}').to_s.split('.').first(2)\" 2&gt;/dev/null\n}\n\ntest_curl() {\n  if [[ ! -x \"$1\" ]]\n  then\n    return 1\n  fi\n\n  if [[ \"$1\" == \"/snap/bin/curl\" ]]\n  then\n    warn \"Ignoring $1 (curl snap is too restricted)\"\n    return 1\n  fi\n\n  local curl_version_output curl_name_and_version\n  curl_version_output=\"$(\"$1\" --version 2&gt;/dev/null)\"\n  curl_name_and_version=\"${curl_version_output%% (*}\"\n  version_ge \"$(major_minor \"${curl_name_and_version##* }\")\" \"$(major_minor \"${REQUIRED_CURL_VERSION}\")\"\n}\n\ntest_git() {\n  if [[ ! -x \"$1\" ]]\n  then\n    return 1\n  fi\n\n  local git_version_output\n  git_version_output=\"$(\"$1\" --version 2&gt;/dev/null)\"\n  if [[ \"${git_version_output}\" =~ \"git version \"([^ ]*).* ]]\n  then\n    version_ge \"$(major_minor \"${BASH_REMATCH[1]}\")\" \"$(major_minor \"${REQUIRED_GIT_VERSION}\")\"\n  else\n    abort \"Unexpected Git version: '${git_version_output}'!\"\n  fi\n}\n\n# Search for the given executable in PATH (avoids a dependency on the `which` command)\nwhich() {\n  # Alias to Bash built-in command `type -P`\n  type -P \"$@\"\n}\n\n# Search PATH for the specified program that satisfies Homebrew requirements\n# function which is set above\n# shellcheck disable=SC2230\nfind_tool() {\n  if [[ $# -ne 1 ]]\n  then\n    return 1\n  fi\n\n  local executable\n  while read -r executable\n  do\n    if [[ \"${executable}\" != /* ]]\n    then\n      warn \"Ignoring ${executable} (relative paths don't work)\"\n    elif \"test_$1\" \"${executable}\"\n    then\n      echo \"${executable}\"\n      break\n    fi\n  done &lt; &lt;(which -a \"$1\")\n}\n\nno_usable_ruby() {\n  [[ -z \"$(find_tool ruby)\" ]]\n}\n\noutdated_glibc() {\n  local glibc_version\n  glibc_version=\"$(ldd --version | head -n1 | grep -o '[0-9.]*$' | grep -o '^[0-9]\\+\\.[0-9]\\+')\"\n  version_lt \"${glibc_version}\" \"${REQUIRED_GLIBC_VERSION}\"\n}\n\nif [[ -n \"${HOMEBREW_ON_LINUX-}\" ]] &amp;&amp; no_usable_ruby &amp;&amp; outdated_glibc\nthen\n  abort \"$(\n    cat &lt;&lt;EOABORT\nHomebrew requires Ruby ${REQUIRED_RUBY_VERSION} which was not found on your system.\nHomebrew portable Ruby requires Glibc version ${REQUIRED_GLIBC_VERSION} or newer,\nand your Glibc version is too old. See:\n  ${tty_underline}https://docs.brew.sh/Homebrew-on-Linux#requirements${tty_reset}\nPlease install Ruby ${REQUIRED_RUBY_VERSION} and add its location to your PATH.\nEOABORT\n  )\"\nfi\n\n# Invalidate sudo timestamp before exiting (if it wasn't active before).\nif [[ -x /usr/bin/sudo ]] &amp;&amp; ! /usr/bin/sudo -n -v 2&gt;/dev/null\nthen\n  trap '/usr/bin/sudo -k' EXIT\nfi\n\n# Things can fail later if `pwd` doesn't exist.\n# Also sudo prints a warning message for no good reason\ncd \"/usr\" || exit 1\n\n####################################################################### script\n\n# shellcheck disable=SC2016\nohai 'Checking for `sudo` access (which may request your password)...'\n\nif [[ -n \"${HOMEBREW_ON_MACOS-}\" ]]\nthen\n  [[ \"${EUID:-${UID}}\" == \"0\" ]] || have_sudo_access\nelif ! [[ -w \"${HOMEBREW_PREFIX}\" ]] &amp;&amp;\n     ! [[ -w \"/home/linuxbrew\" ]] &amp;&amp;\n     ! [[ -w \"/home\" ]] &amp;&amp;\n     ! have_sudo_access\nthen\n  abort \"$(\n    cat &lt;&lt;EOABORT\nInsufficient permissions to install Homebrew to \"${HOMEBREW_PREFIX}\" (the default prefix).\n\nAlternative (unsupported) installation methods are available at:\nhttps://docs.brew.sh/Installation#alternative-installs\n\nPlease note this will require most formula to build from source, a buggy, slow and energy-inefficient \nexperience.\nWe will close any issues without response for these unsupported configurations.\nEOABORT\n  )\"\nfi\nHOMEBREW_CORE=\"${HOMEBREW_REPOSITORY}/Library/Taps/homebrew/homebrew-core\"\n\ncheck_run_command_as_root\n\nif [[ -d \"${HOMEBREW_PREFIX}\" &amp;&amp; ! -x \"${HOMEBREW_PREFIX}\" ]]\nthen\n  abort \"$(\n    cat &lt;&lt;EOABORT\nThe Homebrew prefix ${tty_underline}${HOMEBREW_PREFIX}${tty_reset} exists but is not searchable.\nIf this is not intentional, please restore the default permissions and\ntry running the installer again:\n    sudo chmod 775 ${HOMEBREW_PREFIX}\nEOABORT\n  )\"\nfi\n\nif [[ -n \"${HOMEBREW_ON_MACOS-}\" ]]\nthen\n  # On macOS, support 64-bit Intel and ARM\n  if [[ \"${UNAME_MACHINE}\" != \"arm64\" ]] &amp;&amp; [[ \"${UNAME_MACHINE}\" != \"x86_64\" ]]\n  then\n    abort \"Homebrew is only supported on Intel and ARM processors!\"\n  fi\nelse\n  # On Linux, support only 64-bit Intel\n  if [[ \"${UNAME_MACHINE}\" == \"aarch64\" ]]\n  then\n    abort \"$(\n      cat &lt;&lt;EOABORT\nHomebrew on Linux is not supported on ARM processors.\n  ${tty_underline}https://docs.brew.sh/Homebrew-on-Linux#arm-unsupported${tty_reset}\nEOABORT\n    )\"\n  elif [[ \"${UNAME_MACHINE}\" != \"x86_64\" ]]\n  then\n    abort \"Homebrew on Linux is only supported on Intel processors!\"\n  fi\nfi\n\nif [[ -n \"${HOMEBREW_ON_MACOS-}\" ]]\nthen\n  macos_version=\"$(major_minor \"$(/usr/bin/sw_vers -productVersion)\")\"\n  if version_lt \"${macos_version}\" \"10.7\"\n  then\n    abort \"$(\n      cat &lt;&lt;EOABORT\nYour Mac OS X version is too old. See:\n  ${tty_underline}https://github.com/mistydemeo/tigerbrew${tty_reset}\nEOABORT\n    )\"\n  elif version_lt \"${macos_version}\" \"10.11\"\n  then\n    abort \"Your OS X version is too old.\"\n  elif version_ge \"${macos_version}\" \"${MACOS_NEWEST_UNSUPPORTED}\" ||\n       version_lt \"${macos_version}\" \"${MACOS_OLDEST_SUPPORTED}\"\n  then\n    who=\"We\"\n    what=\"\"\n    if version_ge \"${macos_version}\" \"${MACOS_NEWEST_UNSUPPORTED}\"\n    then\n      what=\"pre-release version\"\n    else\n      who+=\" (and Apple)\"\n      what=\"old version\"\n    fi\n    ohai \"You are using macOS ${macos_version}.\"\n    ohai \"${who} do not provide support for this ${what}.\"\n\n    echo \"$(\n      cat &lt;&lt;EOS\nThis installation may not succeed.\nAfter installation, you will encounter build failures with some formulae.\nPlease create pull requests instead of asking for help on Homebrew\\'s GitHub,\nTwitter or any other official channels. You are responsible for resolving any\nissues you experience while you are running this ${what}.\nEOS\n    )\n\" | tr -d \"\\\\\"\n  fi\nfi\n\nohai \"This script will install:\"\necho \"${HOMEBREW_PREFIX}/bin/brew\"\necho \"${HOMEBREW_PREFIX}/share/doc/homebrew\"\necho \"${HOMEBREW_PREFIX}/share/man/man1/brew.1\"\necho \"${HOMEBREW_PREFIX}/share/zsh/site-functions/_brew\"\necho \"${HOMEBREW_PREFIX}/etc/bash_completion.d/brew\"\necho \"${HOMEBREW_REPOSITORY}\"\n\n# Keep relatively in sync with\n# https://github.com/Homebrew/brew/blob/master/Library/Homebrew/keg.rb\ndirectories=(\n  bin etc include lib sbin share opt var\n  Frameworks\n  etc/bash_completion.d lib/pkgconfig\n  share/aclocal share/doc share/info share/locale share/man\n  share/man/man1 share/man/man2 share/man/man3 share/man/man4\n  share/man/man5 share/man/man6 share/man/man7 share/man/man8\n  var/log var/homebrew var/homebrew/linked\n  bin/brew\n)\ngroup_chmods=()\nfor dir in \"${directories[@]}\"\ndo\n  if exists_but_not_writable \"${HOMEBREW_PREFIX}/${dir}\"\n  then\n    group_chmods+=(\"${HOMEBREW_PREFIX}/${dir}\")\n  fi\ndone\n\n# zsh refuses to read from these directories if group writable\ndirectories=(share/zsh share/zsh/site-functions)\nzsh_dirs=()\nfor dir in \"${directories[@]}\"\ndo\n  zsh_dirs+=(\"${HOMEBREW_PREFIX}/${dir}\")\ndone\n\ndirectories=(\n  bin etc include lib sbin share var opt\n  share/zsh share/zsh/site-functions\n  var/homebrew var/homebrew/linked\n  Cellar Caskroom Frameworks\n)\nmkdirs=()\nfor dir in \"${directories[@]}\"\ndo\n  if ! [[ -d \"${HOMEBREW_PREFIX}/${dir}\" ]]\n  then\n    mkdirs+=(\"${HOMEBREW_PREFIX}/${dir}\")\n  fi\ndone\n\nuser_chmods=()\nmkdirs_user_only=()\nif [[ \"${#zsh_dirs[@]}\" -gt 0 ]]\nthen\n  for dir in \"${zsh_dirs[@]}\"\n  do\n    if [[ ! -d \"${dir}\" ]]\n    then\n      mkdirs_user_only+=(\"${dir}\")\n    elif user_only_chmod \"${dir}\"\n    then\n      user_chmods+=(\"${dir}\")\n    fi\n  done\nfi\n\nchmods=()\nif [[ \"${#group_chmods[@]}\" -gt 0 ]]\nthen\n  chmods+=(\"${group_chmods[@]}\")\nfi\nif [[ \"${#user_chmods[@]}\" -gt 0 ]]\nthen\n  chmods+=(\"${user_chmods[@]}\")\nfi\n\nchowns=()\nchgrps=()\nif [[ \"${#chmods[@]}\" -gt 0 ]]\nthen\n  for dir in \"${chmods[@]}\"\n  do\n    if file_not_owned \"${dir}\"\n    then\n      chowns+=(\"${dir}\")\n    fi\n    if file_not_grpowned \"${dir}\"\n    then\n      chgrps+=(\"${dir}\")\n    fi\n  done\nfi\n\nif [[ \"${#group_chmods[@]}\" -gt 0 ]]\nthen\n  ohai \"The following existing directories will be made group writable:\"\n  printf \"%s\\n\" \"${group_chmods[@]}\"\nfi\nif [[ \"${#user_chmods[@]}\" -gt 0 ]]\nthen\n  ohai \"The following existing directories will be made writable by user only:\"\n  printf \"%s\\n\" \"${user_chmods[@]}\"\nfi\nif [[ \"${#chowns[@]}\" -gt 0 ]]\nthen\n  ohai \"The following existing directories will have their owner set to ${tty_underline}${USER}${tty_reset}:\"\n  printf \"%s\\n\" \"${chowns[@]}\"\nfi\nif [[ \"${#chgrps[@]}\" -gt 0 ]]\nthen\n  ohai \"The following existing directories will have their group set to ${tty_underline}${GROUP}${tty_reset}:\"\n  printf \"%s\\n\" \"${chgrps[@]}\"\nfi\nif [[ \"${#mkdirs[@]}\" -gt 0 ]]\nthen\n  ohai \"The following new directories will be created:\"\n  printf \"%s\\n\" \"${mkdirs[@]}\"\nfi\n\nif should_install_command_line_tools\nthen\n  ohai \"The Xcode Command Line Tools will be installed.\"\nfi\n\nnon_default_repos=\"\"\nadditional_shellenv_commands=()\nif [[ \"${HOMEBREW_BREW_DEFAULT_GIT_REMOTE}\" != \"${HOMEBREW_BREW_GIT_REMOTE}\" ]]\nthen\n  ohai \"HOMEBREW_BREW_GIT_REMOTE is set to a non-default URL:\"\n  echo \"${tty_underline}${HOMEBREW_BREW_GIT_REMOTE}${tty_reset} will be used as the Homebrew/brew Git remote.\"\n  non_default_repos=\"Homebrew/brew\"\n  additional_shellenv_commands+=(\"export HOMEBREW_BREW_GIT_REMOTE=\\\"${HOMEBREW_BREW_GIT_REMOTE}\\\"\")\nfi\n\nif [[ \"${HOMEBREW_CORE_DEFAULT_GIT_REMOTE}\" != \"${HOMEBREW_CORE_GIT_REMOTE}\" ]]\nthen\n  ohai \"HOMEBREW_CORE_GIT_REMOTE is set to a non-default URL:\"\n  echo \"${tty_underline}${HOMEBREW_CORE_GIT_REMOTE}${tty_reset} will be used as the Homebrew/homebrew-core \nGit remote.\"\n  non_default_repos=\"${non_default_repos:-}${non_default_repos:+ and }Homebrew/homebrew-core\"\n  additional_shellenv_commands+=(\"export HOMEBREW_CORE_GIT_REMOTE=\\\"${HOMEBREW_CORE_GIT_REMOTE}\\\"\")\nfi\n\nif [[ -n \"${HOMEBREW_NO_INSTALL_FROM_API-}\" ]]\nthen\n  ohai \"HOMEBREW_NO_INSTALL_FROM_API is set.\"\n  echo \"Homebrew/homebrew-core will be tapped during this ${tty_bold}install${tty_reset} run.\"\nfi\n\nif [[ -z \"${NONINTERACTIVE-}\" ]]\nthen\n  ring_bell\n  wait_for_user\nfi\n\nif [[ -d \"${HOMEBREW_PREFIX}\" ]]\nthen\n  if [[ \"${#chmods[@]}\" -gt 0 ]]\n  then\n    execute_sudo \"${CHMOD[@]}\" \"u+rwx\" \"${chmods[@]}\"\n  fi\n  if [[ \"${#group_chmods[@]}\" -gt 0 ]]\n  then\n    execute_sudo \"${CHMOD[@]}\" \"g+rwx\" \"${group_chmods[@]}\"\n  fi\n  if [[ \"${#user_chmods[@]}\" -gt 0 ]]\n  then\n    execute_sudo \"${CHMOD[@]}\" \"go-w\" \"${user_chmods[@]}\"\n  fi\n  if [[ \"${#chowns[@]}\" -gt 0 ]]\n  then\n    execute_sudo \"${CHOWN[@]}\" \"${USER}\" \"${chowns[@]}\"\n  fi\n  if [[ \"${#chgrps[@]}\" -gt 0 ]]\n  then\n    execute_sudo \"${CHGRP[@]}\" \"${GROUP}\" \"${chgrps[@]}\"\n  fi\nelse\n  execute_sudo \"${INSTALL[@]}\" \"${HOMEBREW_PREFIX}\"\nfi\n\nif [[ \"${#mkdirs[@]}\" -gt 0 ]]\nthen\n  execute_sudo \"${MKDIR[@]}\" \"${mkdirs[@]}\"\n  execute_sudo \"${CHMOD[@]}\" \"ug=rwx\" \"${mkdirs[@]}\"\n  if [[ \"${#mkdirs_user_only[@]}\" -gt 0 ]]\n  then\n    execute_sudo \"${CHMOD[@]}\" \"go-w\" \"${mkdirs_user_only[@]}\"\n  fi\n  execute_sudo \"${CHOWN[@]}\" \"${USER}\" \"${mkdirs[@]}\"\n  execute_sudo \"${CHGRP[@]}\" \"${GROUP}\" \"${mkdirs[@]}\"\nfi\n\nif ! [[ -d \"${HOMEBREW_REPOSITORY}\" ]]\nthen\n  execute_sudo \"${MKDIR[@]}\" \"${HOMEBREW_REPOSITORY}\"\nfi\nexecute_sudo \"${CHOWN[@]}\" \"-R\" \"${USER}:${GROUP}\" \"${HOMEBREW_REPOSITORY}\"\n\nif ! [[ -d \"${HOMEBREW_CACHE}\" ]]\nthen\n  if [[ -n \"${HOMEBREW_ON_MACOS-}\" ]]\n  then\n    execute_sudo \"${MKDIR[@]}\" \"${HOMEBREW_CACHE}\"\n  else\n    execute \"${MKDIR[@]}\" \"${HOMEBREW_CACHE}\"\n  fi\nfi\nif exists_but_not_writable \"${HOMEBREW_CACHE}\"\nthen\n  execute_sudo \"${CHMOD[@]}\" \"g+rwx\" \"${HOMEBREW_CACHE}\"\nfi\nif file_not_owned \"${HOMEBREW_CACHE}\"\nthen\n  execute_sudo \"${CHOWN[@]}\" \"-R\" \"${USER}\" \"${HOMEBREW_CACHE}\"\nfi\nif file_not_grpowned \"${HOMEBREW_CACHE}\"\nthen\n  execute_sudo \"${CHGRP[@]}\" \"-R\" \"${GROUP}\" \"${HOMEBREW_CACHE}\"\nfi\nif [[ -d \"${HOMEBREW_CACHE}\" ]]\nthen\n  execute \"${TOUCH[@]}\" \"${HOMEBREW_CACHE}/.cleaned\"\nfi\n\nif should_install_command_line_tools &amp;&amp; version_ge \"${macos_version}\" \"10.13\"\nthen\n  ohai \"Searching online for the Command Line Tools\"\n  # This temporary file prompts the 'softwareupdate' utility to list the Command Line Tools\n  clt_placeholder=\"/tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress\"\n  execute_sudo \"${TOUCH[@]}\" \"${clt_placeholder}\"\n\n  clt_label_command=\"/usr/sbin/softwareupdate -l |\n                      grep -B 1 -E 'Command Line Tools' |\n                      awk -F'*' '/^ *\\\\*/ {print \\$2}' |\n                      sed -e 's/^ *Label: //' -e 's/^ *//' |\n                      sort -V |\n                      tail -n1\"\n  clt_label=\"$(chomp \"$(/bin/bash -c \"${clt_label_command}\")\")\"\n\n  if [[ -n \"${clt_label}\" ]]\n  then\n    ohai \"Installing ${clt_label}\"\n    execute_sudo \"/usr/sbin/softwareupdate\" \"-i\" \"${clt_label}\"\n    execute_sudo \"/usr/bin/xcode-select\" \"--switch\" \"/Library/Developer/CommandLineTools\"\n  fi\n  execute_sudo \"/bin/rm\" \"-f\" \"${clt_placeholder}\"\nfi\n\n# Headless install may have failed, so fallback to original 'xcode-select' method\nif should_install_command_line_tools &amp;&amp; test -t 0\nthen\n  ohai \"Installing the Command Line Tools (expect a GUI popup):\"\n  execute \"/usr/bin/xcode-select\" \"--install\"\n  echo \"Press any key when the installation has completed.\"\n  getc\n  execute_sudo \"/usr/bin/xcode-select\" \"--switch\" \"/Library/Developer/CommandLineTools\"\nfi\n\nif [[ -n \"${HOMEBREW_ON_MACOS-}\" ]] &amp;&amp; ! output=\"$(/usr/bin/xcrun clang 2&gt;&amp;1)\" &amp;&amp; [[ \"${output}\" == \n*\"license\"* ]]\nthen\n  abort \"$(\n    cat &lt;&lt;EOABORT\nYou have not agreed to the Xcode license.\nBefore running the installer again please agree to the license by opening\nXcode.app or running:\n    sudo xcodebuild -license\nEOABORT\n  )\"\nfi\n\nUSABLE_GIT=/usr/bin/git\nif [[ -n \"${HOMEBREW_ON_LINUX-}\" ]]\nthen\n  USABLE_GIT=\"$(find_tool git)\"\n  if [[ -z \"$(command -v git)\" ]]\n  then\n    abort \"$(\n      cat &lt;&lt;EOABORT\n  You must install Git before installing Homebrew. See:\n    ${tty_underline}https://docs.brew.sh/Installation${tty_reset}\nEOABORT\n    )\"\n  fi\n  if [[ -z \"${USABLE_GIT}\" ]]\n  then\n    abort \"$(\n      cat &lt;&lt;EOABORT\n  The version of Git that was found does not satisfy requirements for Homebrew.\n  Please install Git ${REQUIRED_GIT_VERSION} or newer and add it to your PATH.\nEOABORT\n    )\"\n  fi\n  if [[ \"${USABLE_GIT}\" != /usr/bin/git ]]\n  then\n    export HOMEBREW_GIT_PATH=\"${USABLE_GIT}\"\n    ohai \"Found Git: ${HOMEBREW_GIT_PATH}\"\n  fi\nfi\n\nif ! command -v curl &gt;/dev/null\nthen\n  abort \"$(\n    cat &lt;&lt;EOABORT\nYou must install cURL before installing Homebrew. See:\n  ${tty_underline}https://docs.brew.sh/Installation${tty_reset}\nEOABORT\n  )\"\nelif [[ -n \"${HOMEBREW_ON_LINUX-}\" ]]\nthen\n  USABLE_CURL=\"$(find_tool curl)\"\n  if [[ -z \"${USABLE_CURL}\" ]]\n  then\n    abort \"$(\n      cat &lt;&lt;EOABORT\nThe version of cURL that was found does not satisfy requirements for Homebrew.\nPlease install cURL ${REQUIRED_CURL_VERSION} or newer and add it to your PATH.\nEOABORT\n    )\"\n  elif [[ \"${USABLE_CURL}\" != /usr/bin/curl ]]\n  then\n    export HOMEBREW_CURL_PATH=\"${USABLE_CURL}\"\n    ohai \"Found cURL: ${HOMEBREW_CURL_PATH}\"\n  fi\nfi\n\nohai \"Downloading and installing Homebrew...\"\n(\n  cd \"${HOMEBREW_REPOSITORY}\" &gt;/dev/null || return\n\n  # we do it in four steps to avoid merge errors when reinstalling\n  execute \"${USABLE_GIT}\" \"-c\" \"init.defaultBranch=master\" \"init\" \"--quiet\"\n\n  # \"git remote add\" will fail if the remote is defined in the global config\n  execute \"${USABLE_GIT}\" \"config\" \"remote.origin.url\" \"${HOMEBREW_BREW_GIT_REMOTE}\"\n  execute \"${USABLE_GIT}\" \"config\" \"remote.origin.fetch\" \"+refs/heads/*:refs/remotes/origin/*\"\n\n  # ensure we don't munge line endings on checkout\n  execute \"${USABLE_GIT}\" \"config\" \"--bool\" \"core.autocrlf\" \"false\"\n\n  # make sure symlinks are saved as-is\n  execute \"${USABLE_GIT}\" \"config\" \"--bool\" \"core.symlinks\" \"true\"\n\n  if [[ -z \"${NONINTERACTIVE-}\" ]]\n  then\n    quiet_progress=(\"--quiet\" \"--progress\")\n  else\n    quiet_progress=(\"--quiet\")\n  fi\n  execute \"${USABLE_GIT}\" \"fetch\" \"${quiet_progress[@]}\" \"--force\" \"origin\"\n  execute \"${USABLE_GIT}\" \"fetch\" \"${quiet_progress[@]}\" \"--force\" \"--tags\" \"origin\"\n\n  execute \"${USABLE_GIT}\" \"remote\" \"set-head\" \"origin\" \"--auto\" &gt;/dev/null\n\n  LATEST_GIT_TAG=\"$(\"${USABLE_GIT}\" tag --list --sort=\"-version:refname\" | head -n1)\"\n  if [[ -z \"${LATEST_GIT_TAG}\" ]]\n  then\n    abort \"Failed to query latest Homebrew/brew Git tag.\"\n  fi\n  execute \"${USABLE_GIT}\" \"checkout\" \"--quiet\" \"--force\" \"-B\" \"stable\" \"${LATEST_GIT_TAG}\"\n\n  if [[ \"${HOMEBREW_REPOSITORY}\" != \"${HOMEBREW_PREFIX}\" ]]\n  then\n    if [[ \"${HOMEBREW_REPOSITORY}\" == \"${HOMEBREW_PREFIX}/Homebrew\" ]]\n    then\n      execute \"ln\" \"-sf\" \"../Homebrew/bin/brew\" \"${HOMEBREW_PREFIX}/bin/brew\"\n    else\n      abort \"The Homebrew/brew repository should be placed in the Homebrew prefix directory.\"\n    fi\n  fi\n\n  if [[ -n \"${HOMEBREW_NO_INSTALL_FROM_API-}\" &amp;&amp; ! -d \"${HOMEBREW_CORE}\" ]]\n  then\n    # Always use single-quoted strings with `exp` expressions\n    # shellcheck disable=SC2016\n    ohai 'Tapping homebrew/core because `$HOMEBREW_NO_INSTALL_FROM_API` is set.'\n    (\n      execute \"${MKDIR[@]}\" \"${HOMEBREW_CORE}\"\n      cd \"${HOMEBREW_CORE}\" &gt;/dev/null || return\n\n      execute \"${USABLE_GIT}\" \"-c\" \"init.defaultBranch=master\" \"init\" \"--quiet\"\n      execute \"${USABLE_GIT}\" \"config\" \"remote.origin.url\" \"${HOMEBREW_CORE_GIT_REMOTE}\"\n      execute \"${USABLE_GIT}\" \"config\" \"remote.origin.fetch\" \"+refs/heads/*:refs/remotes/origin/*\"\n      execute \"${USABLE_GIT}\" \"config\" \"--bool\" \"core.autocrlf\" \"false\"\n      execute \"${USABLE_GIT}\" \"config\" \"--bool\" \"core.symlinks\" \"true\"\n      execute \"${USABLE_GIT}\" \"fetch\" \"--force\" \"${quiet_progress[@]}\" \\\n        \"origin\" \"refs/heads/master:refs/remotes/origin/master\"\n      execute \"${USABLE_GIT}\" \"remote\" \"set-head\" \"origin\" \"--auto\" &gt;/dev/null\n      execute \"${USABLE_GIT}\" \"reset\" \"--hard\" \"origin/master\"\n\n      cd \"${HOMEBREW_REPOSITORY}\" &gt;/dev/null || return\n    ) || exit 1\n  fi\n\n  execute \"${HOMEBREW_PREFIX}/bin/brew\" \"update\" \"--force\" \"--quiet\"\n) || exit 1\n\nif [[ \":${PATH}:\" != *\":${HOMEBREW_PREFIX}/bin:\"* ]]\nthen\n  warn \"${HOMEBREW_PREFIX}/bin is not in your PATH.\n  Instructions on how to configure your shell for Homebrew\n  can be found in the 'Next steps' section below.\"\nfi\n\nohai \"Installation successful!\"\necho\n\nring_bell\n\n# Use an extra newline and bold to avoid this being missed.\nohai \"Homebrew has enabled anonymous aggregate formulae and cask analytics.\"\necho \"$(\n  cat &lt;&lt;EOS\n${tty_bold}Read the analytics documentation (and how to opt-out) here:\n  ${tty_underline}https://docs.brew.sh/Analytics${tty_reset}\nNo analytics data has been sent yet (nor will any be during this ${tty_bold}install${tty_reset} run).\nEOS\n)\n\"\n\nohai \"Homebrew is run entirely by unpaid volunteers. Please consider donating:\"\necho \"$(\n  cat &lt;&lt;EOS\n  ${tty_underline}https://github.com/Homebrew/brew#donations${tty_reset}\nEOS\n)\n\"\n\n(\n  cd \"${HOMEBREW_REPOSITORY}\" &gt;/dev/null || return\n  execute \"${USABLE_GIT}\" \"config\" \"--replace-all\" \"homebrew.analyticsmessage\" \"true\"\n  execute \"${USABLE_GIT}\" \"config\" \"--replace-all\" \"homebrew.caskanalyticsmessage\" \"true\"\n) || exit 1\n\nohai \"Next steps:\"\ncase \"${SHELL}\" in\n  */bash*)\n    if [[ -n \"${HOMEBREW_ON_LINUX-}\" ]]\n    then\n      shell_rcfile=\"${HOME}/.bashrc\"\n    else\n      shell_rcfile=\"${HOME}/.bash_profile\"\n    fi\n    ;;\n  */zsh*)\n    if [[ -n \"${HOMEBREW_ON_LINUX-}\" ]]\n    then\n      shell_rcfile=\"${ZDOTDIR:-\"${HOME}\"}/.zshrc\"\n    else\n      shell_rcfile=\"${ZDOTDIR:-\"${HOME}\"}/.zprofile\"\n    fi\n    ;;\n  */fish*)\n    shell_rcfile=\"${HOME}/.config/fish/config.fish\"\n    ;;\n  *)\n    shell_rcfile=\"${ENV:-\"${HOME}/.profile\"}\"\n    ;;\nesac\n\nif grep -qs \"eval \\\"\\$(${HOMEBREW_PREFIX}/bin/brew shellenv)\\\"\" \"${shell_rcfile}\"\nthen\n  if ! [[ -x \"$(command -v brew)\" ]]\n  then\n    cat &lt;&lt;EOS\n- Run this command in your terminal to add Homebrew to your ${tty_bold}PATH${tty_reset}:\n    eval \"\\$(${HOMEBREW_PREFIX}/bin/brew shellenv)\"\nEOS\n  fi\nelse\n  cat &lt;&lt;EOS\n- Run these commands in your terminal to add Homebrew to your ${tty_bold}PATH${tty_reset}:\n    echo &gt;&gt; ${shell_rcfile}\n    echo 'eval \"\\$(${HOMEBREW_PREFIX}/bin/brew shellenv)\"' &gt;&gt; ${shell_rcfile}\n    eval \"\\$(${HOMEBREW_PREFIX}/bin/brew shellenv)\"\nEOS\nfi\n\nif [[ -n \"${non_default_repos}\" ]]\nthen\n  plural=\"\"\n  if [[ \"${#additional_shellenv_commands[@]}\" -gt 1 ]]\n  then\n    plural=\"s\"\n  fi\n  printf -- \"- Run these commands in your terminal to add the non-default Git remote%s for %s:\\n\" \"${plural}\" \n\"${non_default_repos}\"\n  printf \"    echo '# Set non-default Git remote%s for %s.' &gt;&gt; %s\\n\" \"${plural}\" \"${non_default_repos}\" \n\"${shell_rcfile}\"\n  printf \"    echo '%s' &gt;&gt; ${shell_rcfile}\\n\" \"${additional_shellenv_commands[@]}\"\n  printf \"    %s\\n\" \"${additional_shellenv_commands[@]}\"\nfi\n\nif [[ -n \"${HOMEBREW_ON_LINUX-}\" ]]\nthen\n  echo \"- Install Homebrew's dependencies if you have sudo access:\"\n\n  if [[ -x \"$(command -v apt-get)\" ]]\n  then\n    echo \"    sudo apt-get install build-essential\"\n  elif [[ -x \"$(command -v dnf)\" ]]\n  then\n    echo \"    sudo dnf group install development-tools\"\n  elif [[ -x \"$(command -v yum)\" ]]\n  then\n    echo \"    sudo yum groupinstall 'Development Tools'\"\n  elif [[ -x \"$(command -v pacman)\" ]]\n  then\n    echo \"    sudo pacman -S base-devel\"\n  elif [[ -x \"$(command -v apk)\" ]]\n  then\n    echo \"    sudo apk add build-base\"\n  fi\n\n  cat &lt;&lt;EOS\n  For more information, see:\n    ${tty_underline}https://docs.brew.sh/Homebrew-on-Linux${tty_reset}\n- We recommend that you install GCC:\n    brew install gcc\nEOS\nfi\n\ncat &lt;&lt;EOS\n- Run ${tty_bold}brew help${tty_reset} to get started\n- Further documentation:\n    ${tty_underline}https://docs.brew.sh${tty_reset}\n\nEOS\n</code></pre>"},{"location":"examples/raw.githubusercontent.com.fb/","title":"/nvm-sh/nvm/v0.40.1/install.sh","text":""},{"location":"examples/raw.githubusercontent.com.fb/#description","title":"Description","text":"<ul> <li>run <code>curl -s https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash</code> to install nvm Node Version Manager</li> <li>cf https://github.com/nvm-sh/nvm </li> </ul>"},{"location":"examples/raw.githubusercontent.com.fb/#stats","title":"Stats","text":"<pre><code>-------------------------------------------------------------------------------\nLanguage                     files          blank        comment           code\n-------------------------------------------------------------------------------\nBourne Shell                     1             51             52            392\n-------------------------------------------------------------------------------\n</code></pre>"},{"location":"examples/raw.githubusercontent.com.fb/#code","title":"Code","text":"<pre><code>#!/usr/bin/env bash\n\n{ # this ensures the entire script is downloaded #\n\nnvm_has() {\n  type \"$1\" &gt; /dev/null 2&gt;&amp;1\n}\n\nnvm_echo() {\n  command printf %s\\\\n \"$*\" 2&gt;/dev/null\n}\n\nif [ -z \"${BASH_VERSION}\" ] || [ -n \"${ZSH_VERSION}\" ]; then\n  # shellcheck disable=SC2016\n  nvm_echo &gt;&amp;2 'Error: the install instructions explicitly say to pipe the install script to `bash`; please \nfollow them'\n  exit 1\nfi\n\nnvm_grep() {\n  GREP_OPTIONS='' command grep \"$@\"\n}\n\nnvm_default_install_dir() {\n  [ -z \"${XDG_CONFIG_HOME-}\" ] &amp;&amp; printf %s \"${HOME}/.nvm\" || printf %s \"${XDG_CONFIG_HOME}/nvm\"\n}\n\nnvm_install_dir() {\n  if [ -n \"$NVM_DIR\" ]; then\n    printf %s \"${NVM_DIR}\"\n  else\n    nvm_default_install_dir\n  fi\n}\n\nnvm_latest_version() {\n  nvm_echo \"v0.40.1\"\n}\n\nnvm_profile_is_bash_or_zsh() {\n  local TEST_PROFILE\n  TEST_PROFILE=\"${1-}\"\n  case \"${TEST_PROFILE-}\" in\n    *\"/.bashrc\" | *\"/.bash_profile\" | *\"/.zshrc\" | *\"/.zprofile\")\n      return\n    ;;\n    *)\n      return 1\n    ;;\n  esac\n}\n\n#\n# Outputs the location to NVM depending on:\n# * The availability of $NVM_SOURCE\n# * The presence of $NVM_INSTALL_GITHUB_REPO\n# * The method used (\"script\" or \"git\" in the script, defaults to \"git\")\n# NVM_SOURCE always takes precedence unless the method is \"script-nvm-exec\"\n#\nnvm_source() {\n  local NVM_GITHUB_REPO\n  NVM_GITHUB_REPO=\"${NVM_INSTALL_GITHUB_REPO:-nvm-sh/nvm}\"\n  if [ \"${NVM_GITHUB_REPO}\" != 'nvm-sh/nvm' ]; then\n    { nvm_echo &gt;&amp;2 \"$(cat)\" ; } &lt;&lt; EOF\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE REPO IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\n\nThe default repository for this install is \\`nvm-sh/nvm\\`,\nbut the environment variables \\`\\$NVM_INSTALL_GITHUB_REPO\\` is\ncurrently set to \\`${NVM_GITHUB_REPO}\\`.\n\nIf this is not intentional, interrupt this installation and\nverify your environment variables.\nEOF\n  fi\n  local NVM_VERSION\n  NVM_VERSION=\"${NVM_INSTALL_VERSION:-$(nvm_latest_version)}\"\n  local NVM_METHOD\n  NVM_METHOD=\"$1\"\n  local NVM_SOURCE_URL\n  NVM_SOURCE_URL=\"$NVM_SOURCE\"\n  if [ \"_$NVM_METHOD\" = \"_script-nvm-exec\" ]; then\n    NVM_SOURCE_URL=\"https://raw.githubusercontent.com/${NVM_GITHUB_REPO}/${NVM_VERSION}/nvm-exec\"\n  elif [ \"_$NVM_METHOD\" = \"_script-nvm-bash-completion\" ]; then\n    NVM_SOURCE_URL=\"https://raw.githubusercontent.com/${NVM_GITHUB_REPO}/${NVM_VERSION}/bash_completion\"\n  elif [ -z \"$NVM_SOURCE_URL\" ]; then\n    if [ \"_$NVM_METHOD\" = \"_script\" ]; then\n      NVM_SOURCE_URL=\"https://raw.githubusercontent.com/${NVM_GITHUB_REPO}/${NVM_VERSION}/nvm.sh\"\n    elif [ \"_$NVM_METHOD\" = \"_git\" ] || [ -z \"$NVM_METHOD\" ]; then\n      NVM_SOURCE_URL=\"https://github.com/${NVM_GITHUB_REPO}.git\"\n    else\n      nvm_echo &gt;&amp;2 \"Unexpected value \\\"$NVM_METHOD\\\" for \\$NVM_METHOD\"\n      return 1\n    fi\n  fi\n  nvm_echo \"$NVM_SOURCE_URL\"\n}\n\n#\n# Node.js version to install\n#\nnvm_node_version() {\n  nvm_echo \"$NODE_VERSION\"\n}\n\nnvm_download() {\n  if nvm_has \"curl\"; then\n    curl --fail --compressed -q \"$@\"\n  elif nvm_has \"wget\"; then\n    # Emulate curl with wget\n    ARGS=$(nvm_echo \"$@\" | command sed -e 's/--progress-bar /--progress=bar /' \\\n                            -e 's/--compressed //' \\\n                            -e 's/--fail //' \\\n                            -e 's/-L //' \\\n                            -e 's/-I /--server-response /' \\\n                            -e 's/-s /-q /' \\\n                            -e 's/-sS /-nv /' \\\n                            -e 's/-o /-O /' \\\n                            -e 's/-C - /-c /')\n    # shellcheck disable=SC2086\n    eval wget $ARGS\n  fi\n}\n\ninstall_nvm_from_git() {\n  local INSTALL_DIR\n  INSTALL_DIR=\"$(nvm_install_dir)\"\n  local NVM_VERSION\n  NVM_VERSION=\"${NVM_INSTALL_VERSION:-$(nvm_latest_version)}\"\n  if [ -n \"${NVM_INSTALL_VERSION:-}\" ]; then\n    # Check if version is an existing ref\n    if command git ls-remote \"$(nvm_source \"git\")\" \"$NVM_VERSION\" | nvm_grep -q \"$NVM_VERSION\" ; then\n      :\n    # Check if version is an existing changeset\n    elif ! nvm_download -o /dev/null \"$(nvm_source \"script-nvm-exec\")\"; then\n      nvm_echo &gt;&amp;2 \"Failed to find '$NVM_VERSION' version.\"\n      exit 1\n    fi\n  fi\n\n  local fetch_error\n  if [ -d \"$INSTALL_DIR/.git\" ]; then\n    # Updating repo\n    nvm_echo \"=&gt; nvm is already installed in $INSTALL_DIR, trying to update using git\"\n    command printf '\\r=&gt; '\n    fetch_error=\"Failed to update nvm with $NVM_VERSION, run 'git fetch' in $INSTALL_DIR yourself.\"\n  else\n    fetch_error=\"Failed to fetch origin with $NVM_VERSION. Please report this!\"\n    nvm_echo \"=&gt; Downloading nvm from git to '$INSTALL_DIR'\"\n    command printf '\\r=&gt; '\n    mkdir -p \"${INSTALL_DIR}\"\n    if [ \"$(ls -A \"${INSTALL_DIR}\")\" ]; then\n      # Initializing repo\n      command git init \"${INSTALL_DIR}\" || {\n        nvm_echo &gt;&amp;2 'Failed to initialize nvm repo. Please report this!'\n        exit 2\n      }\n      command git --git-dir=\"${INSTALL_DIR}/.git\" remote add origin \"$(nvm_source)\" 2&gt; /dev/null \\\n        || command git --git-dir=\"${INSTALL_DIR}/.git\" remote set-url origin \"$(nvm_source)\" || {\n        nvm_echo &gt;&amp;2 'Failed to add remote \"origin\" (or set the URL). Please report this!'\n        exit 2\n      }\n    else\n      # Cloning repo\n      command git clone \"$(nvm_source)\" --depth=1 \"${INSTALL_DIR}\" || {\n        nvm_echo &gt;&amp;2 'Failed to clone nvm repo. Please report this!'\n        exit 2\n      }\n    fi\n  fi\n  # Try to fetch tag\n  if command git --git-dir=\"$INSTALL_DIR\"/.git --work-tree=\"$INSTALL_DIR\" fetch origin tag \"$NVM_VERSION\" \n--depth=1 2&gt;/dev/null; then\n    :\n  # Fetch given version\n  elif ! command git --git-dir=\"$INSTALL_DIR\"/.git --work-tree=\"$INSTALL_DIR\" fetch origin \"$NVM_VERSION\" \n--depth=1; then\n    nvm_echo &gt;&amp;2 \"$fetch_error\"\n    exit 1\n  fi\n  command git -c advice.detachedHead=false --git-dir=\"$INSTALL_DIR\"/.git --work-tree=\"$INSTALL_DIR\" checkout \n-f --quiet FETCH_HEAD || {\n    nvm_echo &gt;&amp;2 \"Failed to checkout the given version $NVM_VERSION. Please report this!\"\n    exit 2\n  }\n  if [ -n \"$(command git --git-dir=\"$INSTALL_DIR\"/.git --work-tree=\"$INSTALL_DIR\" show-ref \nrefs/heads/master)\" ]; then\n    if command git --no-pager --git-dir=\"$INSTALL_DIR\"/.git --work-tree=\"$INSTALL_DIR\" branch --quiet \n2&gt;/dev/null; then\n      command git --no-pager --git-dir=\"$INSTALL_DIR\"/.git --work-tree=\"$INSTALL_DIR\" branch --quiet -D \nmaster &gt;/dev/null 2&gt;&amp;1\n    else\n      nvm_echo &gt;&amp;2 \"Your version of git is out of date. Please update it!\"\n      command git --no-pager --git-dir=\"$INSTALL_DIR\"/.git --work-tree=\"$INSTALL_DIR\" branch -D master \n&gt;/dev/null 2&gt;&amp;1\n    fi\n  fi\n\n  nvm_echo \"=&gt; Compressing and cleaning up git repository\"\n  if ! command git --git-dir=\"$INSTALL_DIR\"/.git --work-tree=\"$INSTALL_DIR\" reflog expire --expire=now --all; \nthen\n    nvm_echo &gt;&amp;2 \"Your version of git is out of date. Please update it!\"\n  fi\n  if ! command git --git-dir=\"$INSTALL_DIR\"/.git --work-tree=\"$INSTALL_DIR\" gc --auto --aggressive \n--prune=now ; then\n    nvm_echo &gt;&amp;2 \"Your version of git is out of date. Please update it!\"\n  fi\n  return\n}\n\n#\n# Automatically install Node.js\n#\nnvm_install_node() {\n  local NODE_VERSION_LOCAL\n  NODE_VERSION_LOCAL=\"$(nvm_node_version)\"\n\n  if [ -z \"$NODE_VERSION_LOCAL\" ]; then\n    return 0\n  fi\n\n  nvm_echo \"=&gt; Installing Node.js version $NODE_VERSION_LOCAL\"\n  nvm install \"$NODE_VERSION_LOCAL\"\n  local CURRENT_NVM_NODE\n\n  CURRENT_NVM_NODE=\"$(nvm_version current)\"\n  if [ \"$(nvm_version \"$NODE_VERSION_LOCAL\")\" == \"$CURRENT_NVM_NODE\" ]; then\n    nvm_echo \"=&gt; Node.js version $NODE_VERSION_LOCAL has been successfully installed\"\n  else\n    nvm_echo &gt;&amp;2 \"Failed to install Node.js $NODE_VERSION_LOCAL\"\n  fi\n}\n\ninstall_nvm_as_script() {\n  local INSTALL_DIR\n  INSTALL_DIR=\"$(nvm_install_dir)\"\n  local NVM_SOURCE_LOCAL\n  NVM_SOURCE_LOCAL=\"$(nvm_source script)\"\n  local NVM_EXEC_SOURCE\n  NVM_EXEC_SOURCE=\"$(nvm_source script-nvm-exec)\"\n  local NVM_BASH_COMPLETION_SOURCE\n  NVM_BASH_COMPLETION_SOURCE=\"$(nvm_source script-nvm-bash-completion)\"\n\n  # Downloading to $INSTALL_DIR\n  mkdir -p \"$INSTALL_DIR\"\n  if [ -f \"$INSTALL_DIR/nvm.sh\" ]; then\n    nvm_echo \"=&gt; nvm is already installed in $INSTALL_DIR, trying to update the script\"\n  else\n    nvm_echo \"=&gt; Downloading nvm as script to '$INSTALL_DIR'\"\n  fi\n  nvm_download -s \"$NVM_SOURCE_LOCAL\" -o \"$INSTALL_DIR/nvm.sh\" || {\n    nvm_echo &gt;&amp;2 \"Failed to download '$NVM_SOURCE_LOCAL'\"\n    return 1\n  } &amp;\n  nvm_download -s \"$NVM_EXEC_SOURCE\" -o \"$INSTALL_DIR/nvm-exec\" || {\n    nvm_echo &gt;&amp;2 \"Failed to download '$NVM_EXEC_SOURCE'\"\n    return 2\n  } &amp;\n  nvm_download -s \"$NVM_BASH_COMPLETION_SOURCE\" -o \"$INSTALL_DIR/bash_completion\" || {\n    nvm_echo &gt;&amp;2 \"Failed to download '$NVM_BASH_COMPLETION_SOURCE'\"\n    return 2\n  } &amp;\n  for job in $(jobs -p | command sort)\n  do\n    wait \"$job\" || return $?\n  done\n  chmod a+x \"$INSTALL_DIR/nvm-exec\" || {\n    nvm_echo &gt;&amp;2 \"Failed to mark '$INSTALL_DIR/nvm-exec' as executable\"\n    return 3\n  }\n}\n\nnvm_try_profile() {\n  if [ -z \"${1-}\" ] || [ ! -f \"${1}\" ]; then\n    return 1\n  fi\n  nvm_echo \"${1}\"\n}\n\n#\n# Detect profile file if not specified as environment variable\n# (eg: PROFILE=~/.myprofile)\n# The echo'ed path is guaranteed to be an existing file\n# Otherwise, an empty string is returned\n#\nnvm_detect_profile() {\n  if [ \"${PROFILE-}\" = '/dev/null' ]; then\n    # the user has specifically requested NOT to have nvm touch their profile\n    return\n  fi\n\n  if [ -n \"${PROFILE}\" ] &amp;&amp; [ -f \"${PROFILE}\" ]; then\n    nvm_echo \"${PROFILE}\"\n    return\n  fi\n\n  local DETECTED_PROFILE\n  DETECTED_PROFILE=''\n\n  if [ \"${SHELL#*bash}\" != \"$SHELL\" ]; then\n    if [ -f \"$HOME/.bashrc\" ]; then\n      DETECTED_PROFILE=\"$HOME/.bashrc\"\n    elif [ -f \"$HOME/.bash_profile\" ]; then\n      DETECTED_PROFILE=\"$HOME/.bash_profile\"\n    fi\n  elif [ \"${SHELL#*zsh}\" != \"$SHELL\" ]; then\n    if [ -f \"$HOME/.zshrc\" ]; then\n      DETECTED_PROFILE=\"$HOME/.zshrc\"\n    elif [ -f \"$HOME/.zprofile\" ]; then\n      DETECTED_PROFILE=\"$HOME/.zprofile\"\n    fi\n  fi\n\n  if [ -z \"$DETECTED_PROFILE\" ]; then\n    for EACH_PROFILE in \".profile\" \".bashrc\" \".bash_profile\" \".zprofile\" \".zshrc\"\n    do\n      if DETECTED_PROFILE=\"$(nvm_try_profile \"${HOME}/${EACH_PROFILE}\")\"; then\n        break\n      fi\n    done\n  fi\n\n  if [ -n \"$DETECTED_PROFILE\" ]; then\n    nvm_echo \"$DETECTED_PROFILE\"\n  fi\n}\n\n#\n# Check whether the user has any globally-installed npm modules in their system\n# Node, and warn them if so.\n#\nnvm_check_global_modules() {\n  local NPM_COMMAND\n  NPM_COMMAND=\"$(command -v npm 2&gt;/dev/null)\" || return 0\n  [ -n \"${NVM_DIR}\" ] &amp;&amp; [ -z \"${NPM_COMMAND%%\"$NVM_DIR\"/*}\" ] &amp;&amp; return 0\n\n  local NPM_VERSION\n  NPM_VERSION=\"$(npm --version)\"\n  NPM_VERSION=\"${NPM_VERSION:--1}\"\n  [ \"${NPM_VERSION%%[!-0-9]*}\" -gt 0 ] || return 0\n\n  local NPM_GLOBAL_MODULES\n  NPM_GLOBAL_MODULES=\"$(\n    npm list -g --depth=0 |\n    command sed -e '/ npm@/d' -e '/ (empty)$/d'\n  )\"\n\n  local MODULE_COUNT\n  MODULE_COUNT=\"$(\n    command printf %s\\\\n \"$NPM_GLOBAL_MODULES\" |\n    command sed -ne '1!p' |                     # Remove the first line\n    wc -l | command tr -d ' '                   # Count entries\n  )\"\n\n  if [ \"${MODULE_COUNT}\" != '0' ]; then\n    # shellcheck disable=SC2016\n    nvm_echo '=&gt; You currently have modules installed globally with `npm`. These will no'\n    # shellcheck disable=SC2016\n    nvm_echo '=&gt; longer be linked to the active version of Node when you install a new node'\n    # shellcheck disable=SC2016\n    nvm_echo '=&gt; with `nvm`; and they may (depending on how you construct your `$PATH`)'\n    # shellcheck disable=SC2016\n    nvm_echo '=&gt; override the binaries of modules installed with `nvm`:'\n    nvm_echo\n\n    command printf %s\\\\n \"$NPM_GLOBAL_MODULES\"\n    nvm_echo '=&gt; If you wish to uninstall them at a later point (or re-install them under your'\n    # shellcheck disable=SC2016\n    nvm_echo '=&gt; `nvm` node installs), you can remove them from the system Node as follows:'\n    nvm_echo\n    nvm_echo '     $ nvm use system'\n    nvm_echo '     $ npm uninstall -g a_module'\n    nvm_echo\n  fi\n}\n\nnvm_do_install() {\n  if [ -n \"${NVM_DIR-}\" ] &amp;&amp; ! [ -d \"${NVM_DIR}\" ]; then\n    if [ -e \"${NVM_DIR}\" ]; then\n      nvm_echo &gt;&amp;2 \"File \\\"${NVM_DIR}\\\" has the same name as installation directory.\"\n      exit 1\n    fi\n\n    if [ \"${NVM_DIR}\" = \"$(nvm_default_install_dir)\" ]; then\n      mkdir \"${NVM_DIR}\"\n    else\n      nvm_echo &gt;&amp;2 \"You have \\$NVM_DIR set to \\\"${NVM_DIR}\\\", but that directory does not exist. Check your \nprofile files and environment.\"\n      exit 1\n    fi\n  fi\n  # Disable the optional which check, https://www.shellcheck.net/wiki/SC2230\n  # shellcheck disable=SC2230\n  if nvm_has xcode-select &amp;&amp; [ \"$(xcode-select -p &gt;/dev/null 2&gt;/dev/null ; echo $?)\" = '2' ] &amp;&amp; [ \"$(which \ngit)\" = '/usr/bin/git' ] &amp;&amp; [ \"$(which curl)\" = '/usr/bin/curl' ]; then\n    nvm_echo &gt;&amp;2 'You may be on a Mac, and need to install the Xcode Command Line Developer Tools.'\n    # shellcheck disable=SC2016\n    nvm_echo &gt;&amp;2 'If so, run `xcode-select --install` and try again. If not, please report this!'\n    exit 1\n  fi\n  if [ -z \"${METHOD}\" ]; then\n    # Autodetect install method\n    if nvm_has git; then\n      install_nvm_from_git\n    elif nvm_has curl || nvm_has wget; then\n      install_nvm_as_script\n    else\n      nvm_echo &gt;&amp;2 'You need git, curl, or wget to install nvm'\n      exit 1\n    fi\n  elif [ \"${METHOD}\" = 'git' ]; then\n    if ! nvm_has git; then\n      nvm_echo &gt;&amp;2 \"You need git to install nvm\"\n      exit 1\n    fi\n    install_nvm_from_git\n  elif [ \"${METHOD}\" = 'script' ]; then\n    if ! nvm_has curl &amp;&amp; ! nvm_has wget; then\n      nvm_echo &gt;&amp;2 \"You need curl or wget to install nvm\"\n      exit 1\n    fi\n    install_nvm_as_script\n  else\n    nvm_echo &gt;&amp;2 \"The environment variable \\$METHOD is set to \\\"${METHOD}\\\", which is not recognized as a \nvalid installation method.\"\n    exit 1\n  fi\n\n  nvm_echo\n\n  local NVM_PROFILE\n  NVM_PROFILE=\"$(nvm_detect_profile)\"\n  local PROFILE_INSTALL_DIR\n  PROFILE_INSTALL_DIR=\"$(nvm_install_dir | command sed \"s:^$HOME:\\$HOME:\")\"\n\n  SOURCE_STR=\"\\\\nexport NVM_DIR=\\\"${PROFILE_INSTALL_DIR}\\\"\\\\n[ -s \\\"\\$NVM_DIR/nvm.sh\\\" ] &amp;&amp; \\\\. \n\\\"\\$NVM_DIR/nvm.sh\\\"  # This loads nvm\\\\n\"\n\n  # shellcheck disable=SC2016\n  COMPLETION_STR='[ -s \"$NVM_DIR/bash_completion\" ] &amp;&amp; \\. \"$NVM_DIR/bash_completion\"  # This loads nvm \nbash_completion\\n'\n  BASH_OR_ZSH=false\n\n  if [ -z \"${NVM_PROFILE-}\" ] ; then\n    local TRIED_PROFILE\n    if [ -n \"${PROFILE}\" ]; then\n      TRIED_PROFILE=\"${NVM_PROFILE} (as defined in \\$PROFILE), \"\n    fi\n    nvm_echo \"=&gt; Profile not found. Tried ${TRIED_PROFILE-}~/.bashrc, ~/.bash_profile, ~/.zprofile, ~/.zshrc, \nand ~/.profile.\"\n    nvm_echo \"=&gt; Create one of them and run this script again\"\n    nvm_echo \"   OR\"\n    nvm_echo \"=&gt; Append the following lines to the correct file yourself:\"\n    command printf \"${SOURCE_STR}\"\n    nvm_echo\n  else\n    if nvm_profile_is_bash_or_zsh \"${NVM_PROFILE-}\"; then\n      BASH_OR_ZSH=true\n    fi\n    if ! command grep -qc '/nvm.sh' \"$NVM_PROFILE\"; then\n      nvm_echo \"=&gt; Appending nvm source string to $NVM_PROFILE\"\n      command printf \"${SOURCE_STR}\" &gt;&gt; \"$NVM_PROFILE\"\n    else\n      nvm_echo \"=&gt; nvm source string already in ${NVM_PROFILE}\"\n    fi\n    # shellcheck disable=SC2016\n    if ${BASH_OR_ZSH} &amp;&amp; ! command grep -qc '$NVM_DIR/bash_completion' \"$NVM_PROFILE\"; then\n      nvm_echo \"=&gt; Appending bash_completion source string to $NVM_PROFILE\"\n      command printf \"$COMPLETION_STR\" &gt;&gt; \"$NVM_PROFILE\"\n    else\n      nvm_echo \"=&gt; bash_completion source string already in ${NVM_PROFILE}\"\n    fi\n  fi\n  if ${BASH_OR_ZSH} &amp;&amp; [ -z \"${NVM_PROFILE-}\" ] ; then\n    nvm_echo \"=&gt; Please also append the following lines to the if you are using bash/zsh shell:\"\n    command printf \"${COMPLETION_STR}\"\n  fi\n\n  # Source nvm\n  # shellcheck source=/dev/null\n  \\. \"$(nvm_install_dir)/nvm.sh\"\n\n  nvm_check_global_modules\n\n  nvm_install_node\n\n  nvm_reset\n\n  nvm_echo \"=&gt; Close and reopen your terminal to start using nvm or run the following to use it now:\"\n  command printf \"${SOURCE_STR}\"\n  if ${BASH_OR_ZSH} ; then\n    command printf \"${COMPLETION_STR}\"\n  fi\n}\n\n#\n# Unsets the various functions defined\n# during the execution of the install script\n#\nnvm_reset() {\n  unset -f nvm_has nvm_install_dir nvm_latest_version nvm_profile_is_bash_or_zsh \\\n    nvm_source nvm_node_version nvm_download install_nvm_from_git nvm_install_node \\\n    install_nvm_as_script nvm_try_profile nvm_detect_profile nvm_check_global_modules \\\n    nvm_do_install nvm_reset nvm_default_install_dir nvm_grep\n}\n\n[ \"_$NVM_ENV\" = \"_testing\" ] || nvm_do_install\n\n} # this ensures the entire script is downloaded #\n</code></pre>"},{"location":"examples/sdk.cloud.google.com.5a/","title":"sdk.cloud.google.com","text":""},{"location":"examples/sdk.cloud.google.com.5a/#description","title":"Description","text":"<ul> <li>run <code>curl -s https://sdk.cloud.google.com | bash</code> to install Google Cloud SDK</li> <li>cf https://cloud.google.com/sdk/docs/install-sdk </li> </ul>"},{"location":"examples/sdk.cloud.google.com.5a/#stats","title":"Stats","text":"<pre><code>-------------------------------------------------------------------------------\nLanguage                     files          blank        comment           code\n-------------------------------------------------------------------------------\nBourne Shell                     1              5              0             12\n-------------------------------------------------------------------------------\n</code></pre>"},{"location":"examples/sdk.cloud.google.com.5a/#code","title":"Code","text":"<pre><code>#!/bin/bash\n\nURL=https://dl.google.com/dl/cloudsdk/channels/rapid/install_google_cloud_sdk.bash\n\nfunction download {\n  scratch=\"$(mktemp -d -t tmp.XXXXXXXXXX)\" || exit\n  script_file=\"$scratch/install_google_cloud_sdk.bash\"\n\n  echo \"Downloading Google Cloud SDK install script: $URL\"\n  curl -# \"$URL\" &gt; \"$script_file\" || exit\n  chmod 775 \"$script_file\"\n\n  echo \"Running install script from: $script_file\"\n  \"$script_file\" \"$@\"\n}\n\ndownload \"$@\"\n</code></pre>"},{"location":"blog/archive/2026/","title":"2026","text":""},{"location":"blog/category/analysis/","title":"Analysis","text":""}]}