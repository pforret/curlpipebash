{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"curl | bash","text":""},{"location":"#recent-posts","title":"Recent posts","text":"Docker 2026-02-04 php.new 2026-01-15 basherpm/basher 2026-01-08 Homebrew/install 2026-01-01"},{"location":"about/","title":"About this site","text":""},{"location":"about/#what-is-curlpipebashcom","title":"What is curlpipebash.com?","text":"<p>curlpipebash.com is a documentation site that catalogs, analyzes and documents <code>curl | bash</code> installation scripts used by popular open-source projects. Many well-known tools -- Docker, Homebrew, nvm, Laravel and others -- offer a one-liner like this as their recommended installation method:</p> <pre><code>curl -s https://example.com/install.sh | bash\n</code></pre> <p>This site downloads those scripts, runs code analysis on them, and presents the results in a readable format so you can see exactly what each script does before you run it.</p>"},{"location":"about/#what-youll-find-here","title":"What you'll find here","text":"<p>Each example page includes:</p> <ul> <li>The curl command needed to run the script</li> <li>A description of what the script installs</li> <li>A reference link to the project's official documentation</li> <li>Code statistics generated by cloc (lines of code, comments, blank lines)</li> <li>The full source code of the script, so you can read it before piping it to bash</li> </ul> <p>The site also has a blog section with posts about newly analyzed scripts and observations about the <code>curl | bash</code> pattern in the wild.</p>"},{"location":"about/#why-does-this-site-exist","title":"Why does this site exist?","text":"<p>The <code>curl | bash</code> pattern is both convenient and controversial. It lets you install software with a single command, but it also means you're piping code from the internet directly into your shell. That requires trust.</p> <p>This site exists to make that trust more informed. By presenting the full source code and statistics for each script, it lets you:</p> <ul> <li>Inspect before you install -- read the actual code a script will execute</li> <li>Compare approaches -- see how different projects structure their installers</li> <li>Understand the scope -- check how many lines of code you're about to run and in what languages</li> </ul>"},{"location":"about/#projects-covered","title":"Projects covered","text":"<p>The site currently includes installation scripts from projects such as:</p> Project URL What it installs Docker <code>get.docker.com</code> Docker Engine Homebrew <code>brew.sh</code> macOS package manager nvm <code>nvm-sh/nvm</code> Node Version Manager Laravel <code>laravel.build</code> Docker-based Laravel app FrankenPHP <code>frankenphp.dev</code> FrankenPHP server basher <code>basherpm/basher</code> Bash package manager PHP/Composer/Laravel <code>php.new</code> PHP, Composer and Laravel Google Cloud SDK <code>sdk.cloud.google.com</code> Google Cloud CLI tools <p>New scripts are added regularly -- check the blog for the latest additions.</p>"},{"location":"about/#how-its-built","title":"How it's built","text":"<p>The site is built with MkDocs and the Material for MkDocs theme. The example pages are generated automatically by a custom bash script (<code>curlbash.sh</code>) built on the bashew framework. The generation pipeline:</p> <ol> <li>Downloads the installation script via <code>curl</code></li> <li>Runs <code>cloc</code> to produce code statistics</li> <li>Wraps everything into a structured Markdown page</li> <li>MkDocs renders the final HTML</li> </ol> <p>The site is deployed to GitHub Pages via GitHub Actions.</p>"},{"location":"about/#author","title":"Author","text":"<p>This site is maintained by Peter Forret.</p>"},{"location":"best-practices/","title":"Best Practices","text":"<p>Guidance for both script authors and users of curl|bash installers.</p> <ul> <li>Invocation Styles \u2014 comparing <code>curl | bash</code>, <code>curl -o- | bash</code>, and command substitution patterns</li> </ul>"},{"location":"best-practices/invocation/","title":"Invocation Styles","text":"<p>Different projects use different styles to invoke their installer scripts. This page catalogs the common patterns and their trade-offs.</p>"},{"location":"best-practices/invocation/#the-three-main-patterns","title":"The three main patterns","text":""},{"location":"best-practices/invocation/#1-direct-pipe","title":"1. Direct pipe","text":"<pre><code>curl -sL https://example.com/install.sh | bash\n</code></pre> <p>The script streams directly from curl into bash. Simple and common, but vulnerable to partial downloads \u2014 if the connection drops mid-script, bash may execute a truncated script with unpredictable results.</p> <p>Used by: basher, FrankenPHP, Laravel, php.new, Google Cloud SDK</p>"},{"location":"best-practices/invocation/#2-output-to-stdout-explicit","title":"2. Output-to-stdout explicit","text":"<pre><code>curl -o- https://example.com/install.sh | bash\n</code></pre> <p>Functionally identical to <code>-sL</code>, but <code>-o-</code> explicitly writes to stdout instead of relying on curl's default behavior. Some consider this more explicit and readable.</p> <p>Used by: nvm</p>"},{"location":"best-practices/invocation/#3-command-substitution","title":"3. Command substitution","text":"<pre><code>/bin/bash -c \"$(curl -fsSL https://example.com/install.sh)\"\n</code></pre> <p>Downloads the entire script first, then passes it to bash. This eliminates the partial download problem \u2014 if curl fails or the connection drops, bash receives nothing (or an error message) instead of a truncated script.</p> <p>Used by: Homebrew</p>"},{"location":"best-practices/invocation/#curl-flag-combinations","title":"curl flag combinations","text":"Flags Meaning Example users <code>-sL</code> Silent mode, follow redirects basher, FrankenPHP, php.new, Laravel, Google Cloud SDK <code>-fsSL</code> Fail on HTTP error, silent (show errors), follow redirects Docker, Claude Code, OpenClaw, Homebrew <code>-o-</code> Output to stdout (explicit) nvm"},{"location":"best-practices/invocation/#flag-breakdown","title":"Flag breakdown","text":"Flag Purpose <code>-s</code> Silent mode \u2014 no progress meter or error messages <code>-S</code> Show errors even when <code>-s</code> is used <code>-L</code> Follow HTTP redirects (essential for URL shorteners or CDNs) <code>-f</code> Fail silently on HTTP errors (4xx/5xx) \u2014 returns exit code 22 <code>-o-</code> Write output to stdout (explicit, same as default behavior) <p>The <code>-fsSL</code> combination is the most defensive: it follows redirects, stays quiet on success, but surfaces errors and fails properly on HTTP errors.</p>"},{"location":"best-practices/invocation/#wget-equivalents","title":"wget equivalents","text":"<p>Some scripts support both curl and wget. Here are the equivalent commands:</p> curl wget <code>curl -sL URL</code> <code>wget -qO- URL</code> <code>curl -fsSL URL</code> <code>wget -qO- URL</code> (wget fails on HTTP errors by default) <code>curl -o- URL</code> <code>wget -O- URL</code>"},{"location":"best-practices/invocation/#script-level-partial-download-protection","title":"Script-level partial download protection","text":"<p>Well-designed scripts protect themselves against partial downloads, independent of invocation style:</p>"},{"location":"best-practices/invocation/#function-wrapper","title":"Function wrapper","text":"<p>Wrap the entire script body in a function, call it at the end:</p> <pre><code>#!/bin/bash\ndo_install() {\n    # ... entire script here ...\n}\ndo_install\n</code></pre> <p>Used by: Docker \u2014 If the download is truncated before the final <code>do_install</code> call, nothing executes.</p>"},{"location":"best-practices/invocation/#brace-wrapper","title":"Brace wrapper","text":"<p>Wrap the script in braces:</p> <pre><code>{\n    # ... entire script here ...\n}\n</code></pre> <p>Used by: nvm \u2014 bash won't execute the block until it sees the closing brace.</p>"},{"location":"best-practices/invocation/#multi-stage-bootstrap","title":"Multi-stage bootstrap","text":"<p>A small stub script downloads and executes the real installer:</p> <pre><code>#!/bin/bash\n# Stage 1: tiny stub\ncurl -sL https://example.com/real-installer.sh &gt; /tmp/installer.sh\nbash /tmp/installer.sh\nrm /tmp/installer.sh\n</code></pre> <p>Used by: Google Cloud SDK, Claude Code \u2014 The stub is small enough to survive partial downloads; the real installer is downloaded as a file and verified before execution.</p>"},{"location":"best-practices/invocation/#server-side-pipe-detection","title":"Server-side pipe detection","text":"<p>A malicious server can detect whether you're piping to bash or downloading to a file, and serve different content accordingly. This is a real attack vector.</p>"},{"location":"best-practices/invocation/#how-detection-works","title":"How detection works","text":"<p>When you run <code>curl URL | bash</code>, bash executes commands as they arrive \u2014 it doesn't wait for the full download. A server can exploit this timing difference:</p> <ol> <li>Send a payload containing <code>sleep 1</code> followed by buffer-filling data</li> <li>Measure how long the response takes to complete</li> <li>If it takes &gt;1 second, bash is executing (sleeping); serve malicious payload</li> <li>If it completes instantly, user is just downloading; serve harmless payload</li> </ol> <pre><code>// Simplified server-side detection (Go)\nstarted := time.Now()\nres.Write(detect_payload)  // contains sleep + buffer filler\nelapsed := time.Since(started)\n\nif elapsed.Seconds() &gt; 1 {\n    res.Write(malicious_payload)\n} else {\n    res.Write(harmless_payload)\n}\n</code></pre> <p>This means reviewing a script by downloading it first doesn't guarantee you'll see the same script that runs when piped.</p>"},{"location":"best-practices/invocation/#which-patterns-are-vulnerable","title":"Which patterns are vulnerable?","text":"Pattern Detectable? Why <code>curl URL \\| bash</code> Yes Bash executes during download <code>curl -o- URL \\| bash</code> Yes Same streaming behavior <code>/bin/bash -c \"$(curl URL)\"</code> No curl completes before bash starts <code>curl URL &gt; file &amp;&amp; bash file</code> No Download completes before execution <p>The command substitution pattern (<code>$(curl ...)</code>) defeats this attack because curl must finish entirely before bash receives any content. The server cannot distinguish this from a direct download.</p>"},{"location":"best-practices/invocation/#reference","title":"Reference","text":"<p>See The Dangers of curl|bash for a detailed proof-of-concept.</p>"},{"location":"best-practices/invocation/#recommendations","title":"Recommendations","text":"<p>For script authors:</p> <ol> <li>Use the function wrapper or brace wrapper pattern</li> <li>If distributing via CDN with redirects, ensure your docs use <code>-L</code> / <code>-fsSL</code></li> <li>Consider a multi-stage bootstrap with checksum verification for high-security scenarios</li> <li>Publish checksums so users can verify downloads independently</li> </ol> <p>For users:</p> <ol> <li>Prefer <code>-fsSL</code> over <code>-sL</code> to catch HTTP errors</li> <li>Use command substitution to defeat pipe detection attacks:    <pre><code>/bin/bash -c \"$(curl -fsSL https://example.com/install.sh)\"\n</code></pre></li> <li>For maximum security, download, verify checksum, inspect, then execute:    <pre><code>curl -fsSL https://example.com/install.sh -o install.sh\nsha256sum install.sh  # compare against published checksum\nless install.sh       # review the script\nbash install.sh\nrm install.sh\n</code></pre></li> <li>Be aware that downloading first doesn't guarantee you see what <code>curl | bash</code> would execute \u2014 a malicious server can detect the difference</li> </ol>"},{"location":"best-practices/invocation/#interactive-scripts","title":"Interactive scripts","text":"<p>Some installers need user input during execution. When piped through bash, stdin is consumed by the script content. Solutions:</p> <ul> <li>TTY redirection: The script redirects stdin from <code>/dev/tty</code> to restore interactivity. Used by Google Cloud SDK.</li> <li>Environment variables: Accept configuration via env vars instead of prompts. Example: <code>CLOUDSDK_CORE_DISABLE_PROMPTS=1</code></li> <li>Command-line flags: Pass <code>--non-interactive</code> or similar flags.</li> </ul>"},{"location":"blog/","title":"News","text":""},{"location":"blog/2026/01/homebrew/","title":"Homebrew/install","text":"<p>Ever wished installing software on your Mac (or Linux box) was as easy as <code>apt-get</code> on Debian? That's exactly what Homebrew delivers \u2014 the \"missing package manager for macOS\" that's become the go-to way for developers to install tools, libraries, and apps. This script bootstraps the entire Homebrew ecosystem with a single curl command, detecting your OS and architecture, setting up the right directories, and even installing Xcode Command Line Tools if needed.</p> <p></p>"},{"location":"blog/2026/01/homebrew/#script-info","title":"Script info","text":"URL <code>https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh</code> Invocation <code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"</code> Total lines 1167 Comments 65 lines Blank 90 lines Boilerplate 150 lines (output formatting, colors, usage text) Installation 862 lines (actual work)"},{"location":"blog/2026/01/homebrew/#what-does-it-change","title":"What does it change?","text":"<p>This is a seriously thorough installer \u2014 it's been battle-tested by millions of developers and shows it. Let's break down what happens when you let it loose.</p>"},{"location":"blog/2026/01/homebrew/#files-and-folders","title":"Files and folders","text":"<p>The big one: Homebrew creates its own little kingdom on your system.</p> <p>On Apple Silicon Macs (M1/M2/M3):</p> <ul> <li>Creates <code>/opt/homebrew</code> as the main prefix</li> <li>Sets up a whole directory tree underneath: <code>bin</code>, <code>etc</code>, <code>include</code>, <code>lib</code>, <code>sbin</code>, <code>share</code>, <code>opt</code>, <code>var</code>, <code>Cellar</code>, <code>Caskroom</code>, <code>Frameworks</code></li> <li>Creates <code>/etc/paths.d/homebrew</code> so the <code>brew</code> command is automatically in your PATH</li> </ul> <p>On Intel Macs:</p> <ul> <li>Uses <code>/usr/local</code> as the prefix (classic location)</li> <li>Creates <code>/usr/local/Homebrew</code> for the actual Homebrew code</li> <li>Similar subdirectory structure as above</li> </ul> <p>On Linux:</p> <ul> <li>Creates <code>/home/linuxbrew/.linuxbrew</code> (yes, even if your username isn't \"linuxbrew\")</li> <li>Same subdirectory structure</li> </ul> <p>Cache directories:</p> <ul> <li>macOS: <code>~/Library/Caches/Homebrew</code></li> <li>Linux: <code>~/.cache/Homebrew</code></li> </ul>"},{"location":"blog/2026/01/homebrew/#downloads","title":"Downloads","text":"<p>The script clones the Homebrew repository from GitHub:</p> <ul> <li><code>https://github.com/Homebrew/brew</code> \u2014 the main Homebrew codebase</li> <li>Optionally <code>https://github.com/Homebrew/homebrew-core</code> if you set <code>HOMEBREW_NO_INSTALL_FROM_API</code></li> </ul> <p>After the initial clone, it runs <code>brew update</code> to fetch the latest package definitions.</p>"},{"location":"blog/2026/01/homebrew/#packages-installed-macos-only","title":"Packages installed (macOS only)","text":"<p>Here's a heads-up for macOS users: if you don't have Xcode Command Line Tools installed, this script will trigger their installation. That's a ~1GB download from Apple that includes <code>git</code>, compilers, and other developer essentials. The script tries to do this silently in the background, but may pop up a GUI dialog asking you to confirm.</p>"},{"location":"blog/2026/01/homebrew/#environment-changes","title":"Environment changes","text":"<p>The script itself doesn't modify your shell config, but it will politely tell you to add this line to your <code>.zshrc</code>, <code>.bash_profile</code>, or equivalent:</p> <pre><code>eval \"$(brew shellenv)\"\n</code></pre> <p>This sets up <code>PATH</code>, <code>MANPATH</code>, <code>INFOPATH</code>, and a few other environment variables so you can use <code>brew</code> and everything you install with it.</p> <p>On ARM Macs, it also creates <code>/etc/paths.d/homebrew</code> which adds <code>/opt/homebrew/bin</code> to your system PATH automatically \u2014 no shell config editing required for basic functionality.</p>"},{"location":"blog/2026/01/homebrew/#permissions","title":"Permissions","text":"<p>The script needs admin access on macOS (it'll prompt for your password). Here's what it does with those elevated privileges:</p> <ul> <li>Creates and sets ownership on the Homebrew prefix directory</li> <li>Adjusts permissions so your user account owns everything (not root)</li> <li>On macOS, the directories are owned by your user but grouped under <code>admin</code></li> <li>On Linux, it uses your primary group</li> </ul> <p>One nice detail: the script specifically checks that you're not running as root (except in containers). It wants to install things owned by your regular user account, which is the secure way to do it.</p>"},{"location":"blog/2026/01/homebrew/#changed-your-mind","title":"Changed your mind?","text":"<p>Homebrew is actually pretty easy to uninstall cleanly. The Homebrew team provides an official uninstall script:</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)\"\n</code></pre> <p>If you prefer the manual route:</p> <ol> <li>Remove the Homebrew directory:</li> <li>ARM Mac: <code>sudo rm -rf /opt/homebrew</code></li> <li>Intel Mac: <code>sudo rm -rf /usr/local/Homebrew</code> (and carefully remove Homebrew-owned files from <code>/usr/local</code>)</li> <li> <p>Linux: <code>sudo rm -rf /home/linuxbrew</code></p> </li> <li> <p>Remove the paths.d entry (ARM Mac only): <pre><code>sudo rm /etc/paths.d/homebrew\n</code></pre></p> </li> <li> <p>Remove the cache:</p> </li> <li>macOS: <code>rm -rf ~/Library/Caches/Homebrew</code></li> <li> <p>Linux: <code>rm -rf ~/.cache/Homebrew</code></p> </li> <li> <p>Clean up your shell config \u2014 remove the <code>eval \"$(brew shellenv)\"</code> line from your <code>.zshrc</code>/<code>.bash_profile</code>/etc.</p> </li> <li> <p>Xcode Command Line Tools can stay \u2014 they're useful for other things. But if you really want them gone: <code>sudo rm -rf /Library/Developer/CommandLineTools</code></p> </li> </ol>"},{"location":"blog/2026/01/homebrew/#full-source","title":"Full source","text":"<p>The full script source is saved as <code>scripts/raw_githubusercontent_com_Homebrew_install_HEAD_install_sh.txt</code>.</p>"},{"location":"blog/2026/01/basher/","title":"basherpm/basher","text":"<p>Ever wished you could install bash scripts as easily as you install npm packages? That's exactly what basher does \u2014 it's a package manager for shell scripts! This tiny installer (just 62 lines) clones basher to your home directory and wires it into your shell's startup script, so you can start <code>basher install</code>-ing community scripts right away.</p> <p></p>"},{"location":"blog/2026/01/basher/#script-info","title":"Script info","text":"Homepage github.com/basherpm/basher Invocation <code>curl -s https://raw.githubusercontent.com/basherpm/basher/master/install.sh \\| bash</code> Total lines 62 Comments 9 lines Blank 7 lines Boilerplate 6 lines (error handling, status messages) Installation 40 lines (actual work)"},{"location":"blog/2026/01/basher/#what-does-it-change","title":"What does it change?","text":""},{"location":"blog/2026/01/basher/#files-and-folders","title":"Files and folders","text":"<p>The script creates a single new folder in your home directory:</p> <ul> <li><code>~/.basher/</code> \u2014 the entire basher installation lives here, cloned straight from GitHub</li> </ul> <p>It also modifies one of your shell startup files (depending on which shell you use):</p> <ul> <li>bash: appends two lines to <code>~/.bashrc</code></li> <li>zsh: appends two lines to <code>~/.zshrc</code></li> <li>sh: appends two lines to <code>~/.profile</code></li> <li>fish: appends five lines to <code>~/.config/fish/config.fish</code></li> </ul> <p>The clever bit? Every line it adds is tagged with <code>##basher5ea843</code> \u2014 a marker that makes cleanup a breeze later.</p>"},{"location":"blog/2026/01/basher/#downloads","title":"Downloads","text":"<ul> <li>Clones <code>https://github.com/basherpm/basher.git</code> to <code>~/.basher</code></li> </ul> <p>This is a git clone, so you'll get the full repository including git history. On the plus side: easy updates with <code>git pull</code>!</p>"},{"location":"blog/2026/01/basher/#environment-changes","title":"Environment changes","text":"<p>The installer adds basher to your PATH and initializes it on every new shell session:</p> <pre><code>export PATH=\"$HOME/.basher/bin:$PATH\"\neval \"$(basher init - bash)\"  # or zsh, sh, fish\n</code></pre> <p>This means <code>basher</code> will be available in every new terminal window you open after installation.</p>"},{"location":"blog/2026/01/basher/#prerequisites","title":"Prerequisites","text":"<p>Before you dive in, make sure you have:</p> <ul> <li>git installed (the script checks for this and bails if it's missing)</li> <li>One of the supported shells: bash, zsh, sh, or fish</li> </ul> <p>The script is also polite enough to refuse installation if basher is already present in <code>~/.basher</code> or the XDG data directory.</p>"},{"location":"blog/2026/01/basher/#changed-your-mind","title":"Changed your mind?","text":"<p>No hard feelings! Here's how to cleanly remove basher:</p> <ol> <li> <p>Delete the basher directory:    <pre><code>rm -rf ~/.basher\n</code></pre></p> </li> <li> <p>Clean up your shell startup file \u2014 open your <code>.bashrc</code>, <code>.zshrc</code>, <code>.profile</code>, or fish config and remove any lines containing <code>##basher5ea843</code>. There should be 2-5 lines depending on your shell.</p> </li> </ol> <p>For bash/zsh/sh, you can do this automatically:    <pre><code># For bash\nsed -i.bak '/basher5ea843/d' ~/.bashrc\n\n# For zsh\nsed -i.bak '/basher5ea843/d' ~/.zshrc\n\n# For fish\nsed -i.bak '/basher5ea843/d' ~/.config/fish/config.fish\n</code></pre></p> <ol> <li>Start a fresh terminal \u2014 or <code>source</code> your startup file to clear basher from your current session's PATH.</li> </ol> <p>That's it! Your system is back to its pre-basher state.</p>"},{"location":"blog/2026/01/basher/#full-source","title":"Full source","text":"<p>The full script source is saved as <code>scripts/raw_githubusercontent_com_basherpm_basher_master_install_sh.txt</code>.</p>"},{"location":"blog/2026/01/php/","title":"php.new","text":"<p>Ever wanted to go from zero to PHP in under a minute? The <code>php.new</code> installer is Laravel's gift to developers who just want to start coding without wrestling with Homebrew formulas or compilation flags. One curl command and you've got PHP 8.4, Composer, and the Laravel installer ready to roll \u2014 all tucked away in your home directory.</p> <p></p>"},{"location":"blog/2026/01/php/#script-info","title":"Script info","text":"URL <code>https://php.new/install/mac/8.4</code> Invocation <code>/bin/bash -c \"$(curl -fsSL https://php.new/install/mac/8.4)\"</code> Total lines 213 Comments 9 lines Blank 16 lines Boilerplate 48 lines (spinners, colored output, success messages) Installation 140 lines (actual work)"},{"location":"blog/2026/01/php/#what-does-it-change","title":"What does it change?","text":""},{"location":"blog/2026/01/php/#files-and-folders","title":"Files and folders","text":"<p>The script creates a cozy little home for your PHP setup:</p> <ul> <li><code>~/.config/herd-lite/bin/</code> \u2014 the main installation directory</li> <li><code>php</code> \u2014 a standalone PHP 8.4 binary (ARM64 or x64 depending on your Mac)</li> <li><code>composer</code> \u2014 the PHP package manager we all know and love</li> <li><code>laravel</code> \u2014 the Laravel installer for spinning up new projects</li> <li><code>cacert.pem</code> \u2014 SSL certificates so PHP can make secure connections</li> <li><code>php.ini</code> \u2014 basic configuration pointing to those certificates</li> <li><code>uninstall_herd_lite</code> \u2014 a handy cleanup script (how thoughtful!)</li> </ul>"},{"location":"blog/2026/01/php/#downloads","title":"Downloads","text":"<p>The script fetches everything from <code>download.herdphp.com</code>:</p> <ul> <li>PHP binary (architecture-specific \u2014 it checks if you're on Apple Silicon or Intel)</li> <li>Composer binary</li> <li>Laravel installer</li> <li>CA certificate bundle from <code>curl.se</code> (the official source)</li> </ul>"},{"location":"blog/2026/01/php/#environment-changes","title":"Environment changes","text":"<p>Here's where things get a bit more permanent. The script modifies your shell profile to add the install directory to your PATH:</p> <ul> <li>For zsh users: checks <code>~/.zshrc</code>, <code>~/.zprofile</code>, or <code>~/.profile</code></li> <li>For bash users: checks <code>~/.bashrc</code>, <code>~/.bash_profile</code>, or <code>~/.profile</code></li> </ul> <p>It adds two lines to whichever profile file it finds first: <pre><code>export PATH=\"$HOME/.config/herd-lite/bin:$PATH\"\nexport PHP_INI_SCAN_DIR=\"$HOME/.config/herd-lite/bin:$PHP_INI_SCAN_DIR\"\n</code></pre></p> <p>Heads up: If you already have PHP installed via Homebrew or another method, this will put the Herd Lite version first in your PATH. That's usually fine, but worth knowing!</p>"},{"location":"blog/2026/01/php/#permissions","title":"Permissions","text":"<p>All downloaded binaries get marked as executable. No admin permissions needed \u2014 everything lives in your home directory.</p>"},{"location":"blog/2026/01/php/#smart-checks","title":"Smart checks","text":"<p>The script is polite enough to ask before proceeding if it detects you already have the full Laravel Herd app installed. No accidental duplicates here!</p>"},{"location":"blog/2026/01/php/#changed-your-mind","title":"Changed your mind?","text":"<p>Good news \u2014 the script creates its own uninstall helper! Just run:</p> <pre><code>~/.config/herd-lite/bin/uninstall_herd_lite\n</code></pre> <p>This removes the entire <code>~/.config/herd-lite/bin/</code> directory. However, you'll want to manually clean up your shell profile. Open your <code>~/.zshrc</code> (or whichever profile file was modified) and remove these lines:</p> <pre><code>export PATH=\"$HOME/.config/herd-lite/bin:$PATH\"\nexport PHP_INI_SCAN_DIR=\"$HOME/.config/herd-lite/bin:$PHP_INI_SCAN_DIR\"\n</code></pre> <p>Then restart your terminal or run <code>source ~/.zshrc</code> to apply the changes. You're back to square one!</p>"},{"location":"blog/2026/01/php/#full-source","title":"Full source","text":"<p>The full script source is saved as <code>scripts/php_new_install_mac_8_4.txt</code>.</p>"},{"location":"blog/2026/02/docker/","title":"Docker","text":"<p>Want to containerize your life? Docker's one-liner install script is how millions of developers get their container engine up and running on Linux. Run <code>curl -fsSL https://get.docker.com | bash</code> and you'll have Docker Engine, Docker CLI, Docker Compose, Buildx, and containerd ready to spin up containers. The script auto-detects your distro, configures package repos, and installs everything with admin privileges.</p> <p></p>"},{"location":"blog/2026/02/docker/#script-info","title":"Script info","text":"URL <code>https://get.docker.com</code> Invocation <code>curl -fsSL https://get.docker.com \\| bash</code> Total lines 764 Comments 97 lines Blank 35 lines Boilerplate 95 lines (output formatting, deprecation warnings, help text) Installation 537 lines (actual work)"},{"location":"blog/2026/02/docker/#what-does-it-change","title":"What does it change?","text":""},{"location":"blog/2026/02/docker/#files-and-folders","title":"Files and folders","text":"<p>The script creates and modifies several system files:</p> <ul> <li><code>/etc/apt/keyrings/docker.asc</code> \u2014 Docker's GPG signing key for Debian/Ubuntu systems. The script downloads this from Docker's servers and sets it readable by all users.</li> <li><code>/etc/apt/sources.list.d/docker.list</code> \u2014 A new apt repository pointing to Docker's package server, configured for your specific distro and version.</li> <li><code>/etc/yum.repos.d/docker-ce.repo</code> \u2014 For RHEL/CentOS/Fedora users, this is the yum/dnf repository config file.</li> </ul>"},{"location":"blog/2026/02/docker/#packages-installed","title":"Packages installed","text":"<p>Here's what gets added to your system \u2014 it's quite a party:</p> <ul> <li>docker-ce \u2014 The main Docker Engine daemon</li> <li>docker-ce-cli \u2014 Command-line interface for talking to Docker</li> <li>containerd.io \u2014 The container runtime that does the heavy lifting</li> <li>docker-compose-plugin \u2014 Run multi-container apps with a simple YAML file</li> <li>docker-buildx-plugin \u2014 Extended build capabilities with BuildKit</li> <li>docker-ce-rootless-extras \u2014 Tools for running Docker without root (nice for security)</li> <li>docker-model-plugin \u2014 Added in recent versions for AI model management</li> </ul> <p>The script also installs prerequisite packages like <code>ca-certificates</code> and <code>curl</code> if they're missing.</p>"},{"location":"blog/2026/02/docker/#downloads","title":"Downloads","text":"<p>The script fetches from Docker's CDN:</p> <ul> <li>Docker's GPG key from <code>https://download.docker.com/linux/&lt;distro&gt;/gpg</code></li> <li>Repository configuration from <code>https://download.docker.com/linux/&lt;distro&gt;/docker-ce.repo</code> (for RHEL-based systems)</li> </ul> <p>Mirrors are available for users in China (Aliyun and Azure China Cloud).</p>"},{"location":"blog/2026/02/docker/#services","title":"Services","text":"<p>By default, the script enables and starts the Docker service immediately using systemd:</p> <ul> <li><code>docker.service</code> \u2014 Gets enabled and started automatically so Docker's ready to go right after installation</li> </ul> <p>Use <code>--no-autostart</code> if you'd rather start it manually later.</p>"},{"location":"blog/2026/02/docker/#permissions","title":"Permissions","text":"<p>This script needs admin privileges to run \u2014 it'll use whatever's available between your regular user account and root access. It modifies system package repositories and installs system-wide services.</p> <p>Before you yolo this into your terminal, know that:</p> <ul> <li>It runs with elevated permissions throughout</li> <li>It modifies system package manager configuration</li> <li>It installs and enables a system service</li> <li>On systems with existing Docker installs, it warns you and waits 20 seconds before proceeding</li> </ul>"},{"location":"blog/2026/02/docker/#changed-your-mind","title":"Changed your mind?","text":"<p>Docker's pretty great, but if you need to roll back, here's the undo button:</p> <p>For Debian/Ubuntu: <pre><code>sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-compose-plugin docker-buildx-plugin docker-ce-rootless-extras docker-model-plugin\nsudo rm -rf /var/lib/docker /var/lib/containerd\nsudo rm /etc/apt/sources.list.d/docker.list\nsudo rm /etc/apt/keyrings/docker.asc\n</code></pre></p> <p>For RHEL/CentOS/Fedora: <pre><code>sudo dnf remove docker-ce docker-ce-cli containerd.io docker-compose-plugin docker-buildx-plugin docker-ce-rootless-extras docker-model-plugin\n# or use 'yum remove' on older systems\nsudo rm -rf /var/lib/docker /var/lib/containerd\nsudo rm /etc/yum.repos.d/docker-ce.repo\n</code></pre></p> <p>Heads up: removing <code>/var/lib/docker</code> deletes all your images, containers, volumes, and networks. If you've got important data in there, back it up first!</p> <p>The service will stop automatically when you remove the packages, but you can explicitly stop it first with <code>sudo systemctl stop docker</code> if you prefer.</p>"},{"location":"blog/2026/02/docker/#full-source","title":"Full source","text":"<p>The full script source is saved as <code>scripts/get_docker_com.txt</code>.</p>"},{"location":"blog/archive/2026/","title":"2026","text":""},{"location":"blog/category/script/","title":"script","text":""},{"location":"blog/category/getdockercom/","title":"get.docker.com","text":""},{"location":"blog/category/phpnew/","title":"php.new","text":""},{"location":"blog/category/github/","title":"github","text":""},{"location":"blog/category/package-manager/","title":"package-manager","text":""},{"location":"blog/category/brewsh/","title":"brew.sh","text":""}]}